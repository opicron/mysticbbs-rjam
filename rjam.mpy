# -*- coding: utf-8 -*-
# rjam.py
# v0.17

#TODO:fix bug 
#.-----------------| Indexing message bases, hold on ..    |
#PYTHON ERROR (/mystic/themes/default/scripts/rjam.mpy)
#/mystic/themes/default/scripts/rjam.mpy:1005: RuntimeWarning: tp_compare didn't return -1 or -2 for exception
#  if recount == False:
#  File "/mystic/themes/default/scripts/rjam.mpy", line 3526, in <module>
#    main()
#  File "/mystic/themes/default/scripts/rjam.mpy", line 3518, in main
#    treelist()
#  File "/mystic/themes/default/scripts/rjam.mpy", line 2487, in treelist
#    items = loadmainlist(True)
#  File "/mystic/themes/default/scripts/rjam.mpy", line 1129, in loadmainlist
#    get_new_mail_count(count)
#  File "/mystic/themes/default/scripts/rjam.mpy", line 1005, in get_new_mail_count
#    if recount == False:
#TypeError: an integer is required
#
# TODO:
# todo:
# - add mouse support
# - add search > index_search_msg > maillist (with search param, to avoid stuff)
# - add nodebrowser/auto netmail finder on username/boardname?
# - add default bg/fg to ans2str
# - why is first character lost when ans2str regular text
# * better change to PyAnsiLove
# - better ansi determination regular expression
# - split long desc text by word instead of 80 chars 
# * rewrite maillist to show message basehdr in loop and based on current message baseid

# !:
# removed current_mbase to clear things up
# subbed/all view
# (un)subscribe from areas
# list vars in selector line or as separate value
# expect no more than 1(!) private (email) area
# added group/area changer 
# private area can be added to group
# added shutdown check
# hdr and body scrollbars
# quote highlights
# define area (mailcheck)
# full add quotes
# writes jhr and jlr
# full ansi support
# arrow key controlled
# highly customizable
# mci control strings
# show lastread
# strips:
#   |CL,|PA,|PN
# read email filename from config instead of hardcoded
# doesnt count edited messages double (like indexed reader :)
# split longstrings into multiple lines
# reads newscan data from .SCN or from default messagebase
# no longer need to delete emails/netmail, keep history!
# use internal message functions
# if /YOU hide mail areas without mail
# if /NEW hide non-new mail areas (removed-- error when all mail is read)
# if /NEW show first message base with new mail
# if /ALL show all areas
# add group/area looper
# add dynamic message read (only read few messages instead of whole base!)
# better quote highlight, if first trimmed char (within 3 char pos) is a >
# mark all areas as read
# mark area as read
# get private status from messagebase to avoid ==private_bases!



import os, sys, datetime, struct, time, re, ConfigParser #, zlib
from mystic_bbs import *                      # mystic user/config  param_str

###################################################################################################################
# Configuration
###################################################################################################################

#------------------------------------------------------------------------------------------------------
#important: 
#             edit your config.py.sample file and rename it to config.py in the /rjam/ directory.
#
#------------------------------------------------------------------------------------------------------

rjamdir = getcfg()['script']+'rjam'+os.sep    # this is the dir with extra libs and data
sys.path.append(rjamdir)                      # importing this dir to pythons path variable

from ans2str import *                         # ansi2mci parser
import config                                 # configuration

# make sure default settings are loaded
#if not hasattr(config, 'private_bases'):          config.private_bases     = [1]   	
if not hasattr(config, 'datetimefmt'):            config.datetimefmt       = "%d %b %y" #DATETIMEFMT = "%Y-%m-%d %H:%M:%S"
if not hasattr(config, 'rep'):                    config.rep               = {"|PN": ":PN", "|PA": ":PA", "|CL": ":CL"} 
if not hasattr(config, 'clearscr'):               config.clearscr          = '|07|16|CL'
#if not hasattr(config, 'mg_initscreen'):          config.mg_initscreen     = '|16|CL|[X01|[Y07|[K|[Y08|[K|[Y09|[K|[Y10|[K|[Y11|[K|[Y12|[K|[Y13|[K|[Y14|[K|[Y15|[K|[Y16|[K|[Y17|[K|[Y18|[K|[Y19|[K|[Y20|[K|[Y21|[K|[Y22|[K|[Y23|[K|[Y24|[K|[Y01|[X01|DFmsggroups.ans|'
#if not hasattr(config, 'mg_startpos'):            config.mg_startpos       = '|[X22|[Y09'
#if not hasattr(config, 'mg_max_lines'):           config.mg_max_lines      = 12
#if not hasattr(config, 'mg_str_group'):           config.mg_str_group      = '|16|08|$T39|&1 |$X58:'
#if not hasattr(config, 'mg_str_area'):            config.mg_str_area       = '|16|&9|&8|07|$T24|&1|$X48 |[X48|14|$L04|&3|$X53  |07|$L04|&2|$X58  '    #truncated name and right justified count
#if not hasattr(config, 'mg_str_highlight'):       config.mg_str_highlight  = '|19|&9|&8|15|$T24|&1|$X48 |[X48|14|$L04|&3|$X53  |15|$L04|&2|$X58 |16 ' #truncated name and right justified count
#if not hasattr(config, 'mg_str_empty'):           config.mg_str_empty      = '|16|$X58  '
if not hasattr(config, 'mg_str_unsubbed'):        config.mg_str_unsubbed   = '|12-'
if not hasattr(config, 'mg_str_new'):             config.mg_str_new        = '|14*'
if not hasattr(config, 'mg_no_new'):              config.mg_no_new         = '|08'+chr(250)
#if not hasattr(config, 'mg_bar_start'):           config.mg_bar_start     = '|[X60|[Y09'
#if not hasattr(config, 'mg_bar_low'):             config.mg_bar_low       = '|16|08'+chr(176)
#if not hasattr(config, 'mg_bar_high'):            config.mg_bar_high      = '|16|11'+chr(178)
if not hasattr(config, 'mg_totalmsgs'):           config.mg_totalmsgs      = ""
if not hasattr(config, 'mg_newmsgs'):             config.mg_newmsgs        = ""
if not hasattr(config, 'no_unsubscribe_str'):     config.no_unsubscribe_str = "Can't unsubscribe from mandatory area"
if not hasattr(config, 'unsub_from_str'):         config.unsub_from_str     = "Unsubscribed from |&1"
if not hasattr(config, 'sub_to_str'):             config.sub_to_str         = "Subscribed to |&1"
if not hasattr(config, 'view_all_str'):           config.view_all_str       = 'All message bases'
if not hasattr(config, 'view_sub_str'):           config.view_sub_str       = 'Subscribed message bases'
#if not hasattr(config, 'reader_initscreen'):      config.reader_initscreen = '|CL|DFreader.ans|'
#if not hasattr(config, 'max_header_lines'):       config2.getint('reader','max_header_lines')  = 4
#if not hasattr(config, 'hdr_startpos'):           config.hdr_startpos      = '|[X01|[Y03|16'
#if not hasattr(config, 'hdr_str'):                config.hdr_str           = '|11| |&8|16|08|$T32|&1|$X38 |[X38|08|08|$T15|&2 |$X54 |[X54|08|08|&9|08|$T15|&3|$X69 |[X69|08|08|$T09|&4|[X78 |16 |08|'
#if not hasattr(config, 'hdr_str_new'):            config.hdr_str_new       = '|11| |&8|16|07|$T32|&1|$X38 |[X38|08|07|$T15|&2 |$X54 |[X54|08|07|&9|07|$T15|&3|$X69 |[X69|08|07|$T09|&4|[X78 |16 |08|'
#if not hasattr(config, 'hdr_str_selected'):       config.hdr_str_selected  = '|11| |&8|16|15|$T32|&1|08|$X38'+chr(250)+'|[X38|15|$T15|&2|08'+chr(250)+'|$X54'+chr(250)+'|[X54|15|&9|15|$T15|&3|08|$X69'+chr(250)+'|[X69|15|$T09|&4|08|[X78'+chr(250)+'|16 |08|'
#UNUSED if not hasattr(config, 'hdr_str_unread'):         config.hdr_str_unread    = '|05>'
if not hasattr(config, 'hdr_clearstr'):           config.hdr_clearstr      = ' |$X77 '
#if not hasattr(config, 'hdr_bar_start'):          config.hdr_bar_start     = '|[X79|[Y03'
#if not hasattr(config, 'hdr_bar_low'):            config.hdr_bar_low       = '|16|08'+chr(176)
#if not hasattr(config, 'hdr_bar_high'):           config.hdr_bar_high      = '|16|11'+chr(178)
if not hasattr(config, 'mid_first'):              config.mid_first       = "|16|03`------------------------------------------------------------------------------'"
#if not hasattr(config, 'mid_second'):             config.mid_second      = "|16|13::|05::                                                                        |05::|13::"
#if not hasattr(config, 'max_body_lines'):         config.max_body_lines            = 13
#if not hasattr(config, 'msg_body_startpos'):      config.msg_body_startpos         = '|[X01|[Y10'
if not hasattr(config, 'msg_body_clearstr'):      config.msg_body_clearstr         = '|16|[K'
if not hasattr(config, 'msg_body_default'):       config.msg_body_default          = '|09'
if not hasattr(config, 'msg_body_quote_highlight'):config.msg_body_quote_highlight  = '|05'
if not hasattr(config, 'msg_body_low'):           config.msg_body_low              = '|08'
#if not hasattr(config, 'body_bar_start'):         config.body_bar_start            = '|[X71|[Y23'
if not hasattr(config, 'msg_no_messages'):        config.msg_no_messages           = 'No messages in |&1 base found.' #|&1 base name
if not hasattr(config, 'dialog_text_str'):        config.dialog_text_str           = '|15|23|&9|16' #|&9 is the displayed text
if not hasattr(config, 'dialog_press_any_key'):   config.dialog_press_any_key      = '|15|23 [press any key]'
if not hasattr(config, 'delete_msg'):             config.delete_msg                = 'Message removed.'

#-- no edits beyong this point please!

debug = False

# Message base flags

MB_RealNames   = 0x00000001  # 1
MB_KillKludge  = 0x00000002  # 2
MB_Autosigs    = 0x00000004  # 3
MB_NoAttach    = 0x00000008  # 4
MB_Private     = 0x00000010  # 5
MB_PrivReply   = 0x00000020  # 6
MB_AllowANSI   = 0x00000040  # 7

###################################################################################################################
# Keys
###################################################################################################################

#------------------------------------------------------------------------------
KEY_UP       = chr(72)       # Some keyboard code defines returned by input functions
KEY_SPACE    = chr(32)
KEY_DOWN     = chr(80)
KEY_ESCAPE   = chr(27)
KEY_ENTER    = chr(13)
KEY_TAB      = chr(9)
KEY_LEFT     = chr(75)
KEY_RIGHT    = chr(77)
KEY_PGUP     = chr(73)
KEY_PGDN     = chr(81)
KEY_END      = chr(79)
KEY_HOME     = chr(71)
KEY_CTRLA    = chr(1)
KEY_CTRLC    = chr(3)
KEY_CTRLP    = chr(16)
KEY_CTRLD	   = chr(4)
KEY_CTRLN    = chr(14)
KEY_CTRLR    = chr(18)
KEY_CTRLS	   = chr(19)
KEY_CTRLU	   = chr(21)
KEY_CTRLZ    = chr(26)
KEY_QMARK    = chr(63)
#------------------------------------------------------------------------------


###################################################################################################################
# Ansi
###################################################################################################################

#------------------------------------------------------------------------------
#ansi_escape_regex = r'(?:\x1B[@-_]|[\x80-\x9F])[0-?]*[ -/]*[@-~]'
ansi_escape_regex = r'\x1b\[[0-9;]'
ansi_escape = re.compile(ansi_escape_regex)
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# utf codes to ascii
#------------------------------------------------------------------------------
def utf_to_ascii( s ):
    
    dictionary = {
        #remove CNet color codes
        'c0':'|00',
        'c1':'|04', #red (was |12)
        'c2':'|02',
        'c3':'|06',
        'c4':'|01',
        'c5':'|05',
        'c6':config.msg_body_default, #'|03'
        'c7':'|11',              
        'c8':'|08',
        'c9':'|12',
        'ca':'|10', #green
        'cb':'|14', #yellow
        'cc':'|09', 
        'cd':'|13', #magenta
        'ce':'|11',
        'cf':'|15',
        'z0':'', #??
        'z1':'|16',
        'z2':'|18',
        'z3':'|22',        
        'z4':'|17',        
        'z5':'|21',        
        'z6':'|19',        
        'z7':'|23',        
        'q1':'', #default?
        'n1':'', #|CR
        'f1':'', #|CL
        '\xe2\x96\x80':chr(223),
        '\xe2\x96\x84':chr(220),
        '\xe2\x96\x88':chr(219),
        '\xe2\x96\x91':chr(176),
        '\xe2\x96\x92':chr(177),
        '\xe2\x96\x93':chr(178),
        '\xe2\x96\xa0':chr(254), #square
        '\xe2\x80\x99':"'",
        '\xe2\x80\x90':'-',
        '\xe2\x80\x91':'-',
        '\xe2\x80\x92':'-',
        '\xe2\x80\x93':'-',
        '\xe2\x80\x94':'-',
        '\xe2\x80\x94':'-',
        '\xe2\x80\x98':"'",
        '\xe2\x80\x9b':"'",
        '\xe2\x80\x9c':'"',
        '\xe2\x80\x9c':'"',
        '\xe2\x80\x9d':'"',
        '\xe2\x80\x9e':'"',
        '\xe2\x80\x9f':'"',
        '\xe2\x80\xa6':'...',
        '\xe2\x80\xb2':"'",
        '\xe2\x80\xb3':"'",
        '\xe2\x80\xb4':"'",
        '\xe2\x80\xb5':"'",
        '\xe2\x80\xb6':"'",
        '\xe2\x80\xb7':"'",
        '\xe2\x81\xba':"+",
        '\xe2\x81\xbb':"-",
        '\xe2\x81\xbc':"=",
        '\xe2\x81\xbd':"(",
        '\xe2\x81\xbe':")",

        '\xc3\xa9':chr(130), # é
        '\xc2\xa1':chr(173), # ¡ INVERTED EXCLAMATION MARK
        '\xc2\xa2':chr(155), # ¢ CENT SIGN
        '\xc2\xa3':chr(156), # £ POUND SIGN
        #'\xc2\xa4':chr() ¤ CURRENCY SIGN
        '\xc2\xa5':chr(157), # ¥ YEN SIGN
        '\xc2\xa6':'|', # ¦ BROKEN BAR
        # '\xc2\xa7' § SECTION SIGN
        '\xc2\xa8':'"', # ¨ DIAERESIS
        '\xc2\xa9':'(C)', # © COPYRIGHT SIGN
        # '\xc2\xaa' ª FEMININE ORDINAL INDICATOR
        '\xc2\xab':chr(174), # « LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
        '\xc2\xac':chr(170), # ¬ NOT SIGN
        '\xc2\xad':'-', # ­ SOFT HYPHEN
        '\xc2\xae':'(R)', # ® REGISTERED SIGN
        '\xc2\xaf':'-', # ¯ MACRON
        '\xc2\xb0':chr(248), # ° DEGREE SIGN
        '\xc2\xb1':chr(241), # ± PLUS-MINUS SIGN
        '\xc2\xb2':chr(253), # ² SUPERSCRIPT TWO
        # '\xc2\xb3' ³ SUPERSCRIPT THREE
        '\xc2\xb4':"'", # ´ ACUTE ACCENT
        '\xc2\xb5':chr(230), # µ MICRO SIGN
        # '\xc2\xb6' ¶ PILCROW SIGN
        '\xc2\xb7':chr(249), # · MIDDLE DOT
        '\xc2\xb8':chr(250), # ¸ CEDILLA
        # '\xc2\xb9' ¹ SUPERSCRIPT ONE
        # '\xc2\xba' º MASCULINE ORDINAL INDICATOR
        '\xc2\xbb':'>>', # » RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
        '\xc2\xbc':chr(172), # ¼ VULGAR FRACTION ONE QUARTER
        '\xc2\xbd':chr(171), # ½ VULGAR FRACTION ONE HALF
        # '\xc2\xbe' ¾ VULGAR FRACTION THREE QUARTERS
        '\xc2\xbf':chr(168), # ¿ INVERTED QUESTION MARK

        '\xc3\x80':chr(133), # À LATIN CAPITAL LETTER A WITH GRAVE
        '\xc3\x81':chr(160), # Á LATIN CAPITAL LETTER A WITH ACUTE
        '\xc3\x82':chr(131), # Â LATIN CAPITAL LETTER A WITH CIRCUMFLEX
        '\xc3\x83':chr(131), # Ã LATIN CAPITAL LETTER A WITH TILDE
        '\xc3\x84':chr(142), # Ä LATIN CAPITAL LETTER A WITH DIAERESIS
        '\xc3\x85':chr(143), # Å LATIN CAPITAL LETTER A WITH RING ABOVE
        '\xc3\x86':chr(146), # Æ LATIN CAPITAL LETTER AE
        '\xc3\x87':chr(128), # Ç LATIN CAPITAL LETTER C WITH CEDILLA
        '\xc3\x88':chr(144), # È LATIN CAPITAL LETTER E WITH GRAVE
        '\xc3\x89':chr(144), # É LATIN CAPITAL LETTER E WITH ACUTE
        '\xc3\x8a':chr(136), # Ê LATIN CAPITAL LETTER E WITH CIRCUMFLEX
        '\xc3\x8b':chr(137), # Ë LATIN CAPITAL LETTER E WITH DIAERESIS
        '\xc3\x8c':chr(141), # Ì LATIN CAPITAL LETTER I WITH GRAVE
        '\xc3\x8d':chr(161), # Í LATIN CAPITAL LETTER I WITH ACUTE
        '\xc3\x8e':chr(140), # Î LATIN CAPITAL LETTER I WITH CIRCUMFLEX
        '\xc3\x8f':chr(139), # Ï LATIN CAPITAL LETTER I WITH DIAERESIS
        '\xc3\x90':'D', # Ð LATIN CAPITAL LETTER ETH
        '\xc3\x91':chr(165), # Ñ LATIN CAPITAL LETTER N WITH TILDE
        '\xc3\x92':chr(149), # Ò LATIN CAPITAL LETTER O WITH GRAVE
        '\xc3\x93':chr(162), # Ó LATIN CAPITAL LETTER O WITH ACUTE
        '\xc3\x94':chr(147), # Ô LATIN CAPITAL LETTER O WITH CIRCUMFLEX
        '\xc3\x95':chr(153), # Õ LATIN CAPITAL LETTER O WITH TILDE
        '\xc3\x96':chr(153), # Ö LATIN CAPITAL LETTER O WITH DIAERESIS
        '\xc3\x97':'x', # × MULTIPLICATION SIGN
        '\xc3\x98':chr(237), # Ø LATIN CAPITAL LETTER O WITH STROKE
        '\xc3\x99':chr(151), # Ù LATIN CAPITAL LETTER U WITH GRAVE
        '\xc3\x9a':chr(163), # Ú LATIN CAPITAL LETTER U WITH ACUTE
        '\xc3\x9b':chr(150), # Û LATIN CAPITAL LETTER U WITH CIRCUMFLEX
        '\xc3\x9c':chr(154), # Ü LATIN CAPITAL LETTER U WITH DIAERESIS
        '\xc3\x9d':'Y', # Ý LATIN CAPITAL LETTER Y WITH ACUTE
        # '\xc3\x9e': Þ LATIN CAPITAL LETTER THORN
        '\xc3\x9f':chr(225), # ß LATIN SMALL LETTER SHARP S
        '\xc3\xa0':chr(133), # à LATIN SMALL LETTER A WITH GRAVE
        '\xc3\xa1':chr(160), # á LATIN SMALL LETTER A WITH ACUTE
        '\xc3\xa2':chr(131), # â LATIN SMALL LETTER A WITH CIRCUMFLEX
        '\xc3\xa3':'a', # ã LATIN SMALL LETTER A WITH TILDE
        '\xc3\xa4':chr(132), # ä LATIN SMALL LETTER A WITH DIAERESIS
        '\xc3\xa5':chr(134), # å LATIN SMALL LETTER A WITH RING ABOVE
        '\xc3\xa6':chr(145), # æ LATIN SMALL LETTER AE
        '\xc3\xa7':chr(134), # ç LATIN SMALL LETTER C WITH CEDILLA
        '\xc3\xa8':chr(138), # è LATIN SMALL LETTER E WITH GRAVE
        '\xc3\xa9':chr(138), # é LATIN SMALL LETTER E WITH ACUTE
        '\xc3\xaa':chr(136), # ê LATIN SMALL LETTER E WITH CIRCUMFLEX
        '\xc3\xab':chr(137), # ë LATIN SMALL LETTER E WITH DIAERESIS
        '\xc3\xac':chr(141), # ì LATIN SMALL LETTER I WITH GRAVE
        '\xc3\xad':chr(161), # í LATIN SMALL LETTER I WITH ACUTE
        '\xc3\xae':chr(140), # î LATIN SMALL LETTER I WITH CIRCUMFLEX
        '\xc3\xaf':chr(139), # ï LATIN SMALL LETTER I WITH DIAERESIS
        '\xc3\xb0':chr(235), # ð LATIN SMALL LETTER ETH
        '\xc3\xb1':chr(164), # ñ LATIN SMALL LETTER N WITH TILDE
        '\xc3\xb2':chr(149), # ò LATIN SMALL LETTER O WITH GRAVE
        '\xc3\xb3':chr(162), # ó LATIN SMALL LETTER O WITH ACUTE
        '\xc3\xb4':chr(147), # ô LATIN SMALL LETTER O WITH CIRCUMFLEX
        '\xc3\xb5':'o', # õ LATIN SMALL LETTER O WITH TILDE
        '\xc3\xb6':chr(148), # ö LATIN SMALL LETTER O WITH DIAERESIS
        '\xc3\xb7':chr(246), # ÷ DIVISION SIGN
        '\xc3\xb8':chr(237), # ø LATIN SMALL LETTER O WITH STROKE
        '\xc3\xb9':chr(164), # ù LATIN SMALL LETTER U WITH GRAVE
        '\xc3\xba':chr(164), # ú LATIN SMALL LETTER U WITH ACUTE
        '\xc3\xbb':'u', # û LATIN SMALL LETTER U WITH CIRCUMFLEX
        '\xc3\xbc':chr(129), # ü LATIN SMALL LETTER U WITH DIAERESIS
        '\xc3\xbd':'y', # ý LATIN SMALL LETTER Y WITH ACUTE
        # '\xc3\xbe' þ LATIN SMALL LETTER THORN
        '\xc3\xbf':chr(152), # ÿ LATIN SMALL LETTER Y WITH DIAERESIS

        '\xf9\xa4':'u',
        '\xc4\x99':'e',
        '\xc4\x97':'e',
        '\xc4\x93':'e'
    }

    #replace extended chars with ascii counterparts
    for key in dictionary.keys():
        #p = re.compile(key,re.UNICODE)
        #s = re.sub(p,dictionary[key],s) #or #s = re.sub(key,dictionary[key],s)
        s = re.sub(key,dictionary[key],s, flags=re.IGNORECASE) #or #s = re.sub(key,dictionary[key],s)
    
    return s
#------------------------------------------------------------------------------

###################################################################################################################
# Defs
###################################################################################################################


#------------------------------------------------------------------------------
class MyConfigParser(ConfigParser.RawConfigParser):
    """ custom parse to make sure qoutes are trimmed """
    def get(self, section, option):
        val = ConfigParser.RawConfigParser.get(self, section, option)
        if isinstance(val, (int, float)):
            return val
        return val.strip('"') #.strip("'")

def load_config():
    """ load config with backward compatibility to mystic a47 and lower """

    global config2
    global rjamdir
    global datapath

    config2 = MyConfigParser() #config2 = ConfigParser.SafeConfigParser()
    #scriptdir = bbs.getcfg()['script']+'rjam'+os.sep    
    #datapath = bbs.getcfg()['data']

    # set default configurations
    defaultcfg = rjamdir+'default.ini'
    customcfg = rjamdir+'custom.ini'
    defaultcfg_wide = rjamdir+'default.ini'
    customcfg_wide = rjamdir+'custom.ini'

    config2.read(defaultcfg)
    config2.read(customcfg)

    # test mystic 1.12a48 configuration capability
    x, y = termsize()

    try:
        find_config('test','ini')
    except AttributeError as e:
        if os.path.exists(rjamdir+'default.c'+str(x)+'x'+str(y)+'.ini'):
            defaultcfg_wide = rjamdir+'default.c'+str(x)+'x'+str(y)+'.ini'
        elif os.path.exists(rjamdir+'default.c'+str(x)+'.ini'):
            defaultcfg_wide = rjamdir+'default.c'+str(x)+'.ini'

        if os.path.exists(rjamdir+'custom.c'+str(x)+'x'+str(y)+'.ini'):
            customcfg_wide = rjamdir+'custom.c'+str(x)+'x'+str(y)+'.ini'
        elif os.path.exists(rjamdir+'custom.c'+str(x)+'.ini'):
            customcfg_wide = rjamdir+'custom.c'+str(x)+'.ini'    
        pass
    else:        
        defaultcfg_wide = find_config(rjamdir+'default','ini')            
        customcfg_wide = find_config(rjamdir+'custom','.ini')            

    #only load when different to original configuration
    if defaultcfg_wide != None and defaultcfg != defaultcfg_wide:
        config2.read(defaultcfg_wide)

    #only load when different to original configuration    
    if customcfg_wide != None and customcfg != customcfg_wide:
        config2.read(customcfg_wide)
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def clrscr():
  write(config.clearscr)
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def pause(visible=False):
  if not visible:
    write('|PN')
  else:
    write('|PA')
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def stripmcicolor (s):

    #match only 00-19 and 20-23
    s = re.sub( r'\|([0-1][0-9]|[2][0-3])', '', s )
    
    return s
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
def stripmci (str):
	pos = str.find("|")
 	while pos != -1:
		str = str[:pos] + str[pos+3:]
		pos = str.find("|")
	return str
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def xwindow(title,typo,x1,y1,x2,y2):
  write('|#X#'+str(typo)+'#'+str(title)+'#'+str(x1)+'#'+str(y1)+'#'+str(x2)+'#'+str(y2)+'#');
#------------------------------------------------------------------------------  


#------------------------------------------------------------------------------
def msgdialog(title,text,p=True):
  s = config.dialog_text_str.replace('|&9',text) + config.dialog_press_any_key
  a = len(stripmci(s))
  if a<75:
    xwindow(title,1,40-(a // 2)-2,10,40+(a // 2)+2,14)
    gotoxy(40-(a // 2),12)
    write(s)

  if p: pause()  
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def updatebar(start_pos, index, total, height, vertical=True, redraw=False):

    if not hasattr(updatebar, 'bar_oldpos_x'):
        updatebar.bar_oldpos_x = -1  # initialize once

    if not hasattr(updatebar, 'bar_oldpos_y'):
        updatebar.bar_oldpos_y = -1  # initialize once

    #if 'bar_oldpos_x' not in globals():
    #    bar_oldpos_x = -1
    #if 'bar_oldpos_y' not in globals():
    #    bar_oldpos_y = -1

    if vertical == True:
      if redraw == True:
        for i in range(0,height+1):
          pos = mci_adjust_y(start_pos,i)
          write(pos+config2.get('group','bar_low'))
      
      y = 0
      if total > 0: 
          y = (index * (height)) // total    

      if y < 0:
        y == 0
      
      if y > height:
          y = height

      if updatebar.bar_oldpos_y <> y or redraw:
        if updatebar.bar_oldpos_y != -1:
          pos = mci_adjust_y(start_pos,updatebar.bar_oldpos_y)
          write(pos+config2.get('group','bar_low'))

        pos = mci_adjust_y(start_pos,y)        
        write(pos+config2.get('group','bar_high'))

      updatebar.bar_oldpos_y = y

    else:

      barlen = 6
      #(height // 2)

      
      #total = total - height
      #if total < height:
      #  index = total

      if total < 1:
        x = barlen
      else:
        x = index * barlen // total

      #background
      #for i in range(x,barlen):
      if updatebar.bar_oldpos_x <> x or redraw:

        i = 0
        while i < barlen:
          pos = mci_adjust_x(start_pos,i)
          write(pos+config2.get('body','bar_low'))
          i += 1

        #for i in range(0,x):
        i = 0
        while i < x:
          pos = mci_adjust_x(start_pos,i)  
          write(pos+config2.get('body','bar_high')) 
          i += 1
          
      """
      #draw only difference
      else:
        if bar_oldpos_x > x:
          pos = mci_adjust_x(start_pos,bar_oldpos_x)  
          write(pos+config2.get('body','bar_low')) 
        else:
          #gotoxy(1,1)
          #write(str(x)+' '+str(bar_oldpos_x)+' ')
          pos = mci_adjust_x(start_pos,x)  
          write(pos+config2.get('body','bar_high')) 
      """

      updatebar.bar_oldpos_x = x
      #write(str(index)+' '+str(total))
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def get_quote_from_name(name):
  if name.find(' ') == -1:
    return name[:2]
  else:
    quote = ""
    for word in name.split(): 
      quote += word[0]

    return quote[:2]
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def issysop():
  global user
  global sysop_level

  if user['level'] >= sysop_level:
    return True
  else:
    return False
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def TimeStr(t):
  return time.strftime(config.datetimefmt, time.gmtime(t)) if t != 0 else "0"
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def getgroupfromacs(acs):
  p = acs.find('g')
  if p < 0:
    return -1
  p += 1
  v = ''
  while True:
    c = acs[p:p+1]
    if ord(c) in range(48,58):
      v += c
    else:
      break
    p += 1
    if p ==  len(acs): break
  return int(v)
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def getlevelfromacs(acs):
  p = acs.find('s')
  if p < 0:
    return -1
  p += 1
  v = ''
  while True:
    c = acs[p:p+1]
    if ord(c) in range(48,58):
      v += c
    else:
      break
    p += 1
    if p ==  len(acs): break
  return int(v)
#------------------------------------------------------------------------------


###################################################################################################################
# Group / Area functions
###################################################################################################################


#------------------------------------------------------------------------------
def get_mailbases():
    global mailgroups
    global mailbases

    mailgroups =  []
    mailbases =   []
    nogrouparea = []    

    #init for group loop
    mg = []
    i = 0

    #get groups by file record position
    while mg != None:

      mg = getmgroup(i)

      #if message group exists
      if mg != None:
  
        if access(mg['acs']):

          #add group to list
          mailgroups.append(mg)

          #change mailgroup to read areas
          menucmd('MG',str(mg['id']))
          
          #init for area loop
          mb = []
          j = 0

          #get areas by record position
          while mb != None:
            mb = getmbase(j)

            # if area exists
            if mb != None:
                            
              if 'EMAILNETMAIL' in actions:
                #if mb['id'] not in config.private_bases:
                #double check! if we only mean netmail and email
                if mb['nettype'] == 1:
                  j += 1
                  continue

              group = getgroupfromacs(mb['listacs'])

              if access(mb['listacs']) and group != -1: 
                
                mb['groupid'] = mg['id']
                mailbases.append(mb)
                
                """
                if issysop():
                  if mb['id'] == 73:
                    #         +     private
                    #           +   public
                    # 1 =  01010000 localmsg          MW
                    # 27 = 01010100 netmail           MW
                    # 73 = 01000100 general public    MP
                    # 41 = 01000100 echo public       MP
                    if bool(mb['flags'] & MB_Private):
                      writeln('private')
                      bits = bin(mb['flags'])[2:].zfill(8)
                      writeln(bits)
                      write('|PA')
                """

              #if no group add area to start of list
              elif access(mb['listacs']) and group == -1:                            
              
                #keep track of added areas without group
                if j not in nogrouparea:
                  nogrouparea.append(j)
                  mb['groupid'] = -1;                
                  mailbases.insert(0,mb)              

            j += 1

      i += 1                
#------------------------------------------------------------------------------


###################################################################################################################
# Message base functions
###################################################################################################################

"""
###################################################################################################################
# JAM vars
###################################################################################################################

#------------------------------------------------------------------------------
STATUSBITS = \
{
  "MSG_REMOVED"      : 0x00000000L     # 0st bit > LocalMsg
, "MSG_LOCAL"        : 0x00000001L     # 0st bit > LocalMsg
, "MSG_INTRANSIT"    : 0x00000002L     # 1nd bit > Msg is in-transit 
, "MSG_PRIVATE"      : 0x00000004L     # 2rd bit > Private 
, "MSG_READ"         : 0x00000008L     # 3th bit > Read by addressee
, "MSG_SENT"         : 0x00000010L     # Sent to remote
, "MSG_KILLSENT"     : 0x00000020L     # Kill when sent
, "MSG_ARCHIVESENT"  : 0x00000040L     # Archive when sent
, "MSG_HOLD"         : 0x00000080L     # Hold for pick-up
, "MSG_CRASH"        : 0x00000100L     # Crash
, "MSG_IMMEDIATE"    : 0x00000200L     # Send Msg now, ignore restrictions
, "MSG_DIRECT"       : 0x00000400L     # 10 Send directly to destination
, "MSG_GATE"         : 0x00000800L     # Send via gateway
, "MSG_FILEREQUEST"  : 0x00001000L     # File request
, "MSG_FILEATTACH"   : 0x00002000L     # File(s) attached to Msg
, "MSG_TRUNCFILE"    : 0x00004000L     # Truncate file(s) when sent
, "MSG_KILLFILE"     : 0x00008000L     # Delete file(s) when sent
, "MSG_RECEIPTREQ"   : 0x00010000L     # Return receipt requested
, "MSG_CONFIRMREQ"   : 0x00020000L     # Confirmation receipt requested
, "MSG_ORPHAN"       : 0x00040000L     # Unknown destination
, "MSG_ENCRYPT"      : 0x00080000L     # Msg text is encrypted
, "MSG_COMPRESS"     : 0x00100000L     # 20 Msg text is compressed
, "MSG_ESCAPED"      : 0x00200000L     # Msg text is seven bit ASCII
, "MSG_FPU"          : 0x00400000L     # Force pickup
, "MSG_TYPELOCAL"    : 0x00800000L     # Msg is for local use only (no export)
, "MSG_TYPEECHO"     : 0x01000000L     # Msg is for conference distribution
, "MSG_TYPENET"      : 0x02000000L     # Msg is direct network mail
, "MSG_NODISP"       : 0x20000000L     # Msg may not be displayed to user
, "MSG_LOCKED"       : 0x40000000L     # Msg is locked, no editing possible
, "MSG_DELETED"      : 0x80000000L     # 31 Msg is deleted
}
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
SUBFIELDTYPES = \
{
  0      : "OADDRESS"
, 1      : "DADDRESS"
, 2      : "SENDERNAME"
, 3      : "RECVRNAME"
, 4      : "MSGID"
, 5      : "REPLYID"
, 6      : "SUBJECT"
, 7      : "PID"
, 8      : "TRACE"
, 9      : "ENCLFILE"
, 10     : "ENCLFWALIAS"
, 11     : "ENCLFREQ"
, 12     : "ENCLFILEWC"
, 13     : "ENCLINDFILE"
, 1000   : "EMBINDAT"
, 2000   : "FTSKLUDGE"
, 2001   : "SEENBY2D"
, 2002   : "PATH2D"
, 2003   : "FLAGS"
, 2004   : "TZUTCINFO"
, 0xffff : "UNKNOWN"
}
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def get_msg_base_hdr(jhrf):
    
    #this function moves the pointer past the header to read messages
    mbase_meta = dict()
    
    fmthdr = "<4s5L1000x"
    fmthdr_s = struct.calcsize(fmthdr)
    hdrstr = jhrf.read(fmthdr_s)

    if len(hdrstr) > fmthdr_s:
      #if not empty unpack
      hdr = struct.unpack(fmthdr, hdrstr)
        
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
## next message/r
#------------------------------------------------------------------------------
def raw_get_msgs(jhrf):
    global user

    # /*
    # **  Message header
    # */
    # typedef struct
    # {
    #     CHAR8   Signature[4];              /* <J><A><M> followed by <NUL> */
    #     UINT16  Revision;                  /* CURRENTREVLEV */
    #     UINT16  ReservedWord;              /* Reserved */
    #     UINT32  SubfieldLen;               /* Length of subfields */
    #     UINT32  TimesRead;                 /* Number of times message read */
    #     UINT32  MsgIdCRC;                  /* CRC-32 of MSGID line */
    #     UINT32  ReplyCRC;                  /* CRC-32 of REPLY line */
    #     UINT32  ReplyTo;                   /* This msg is a reply to.. */
    #     UINT32  Reply1st;                  /* First reply to this msg */
    #     UINT32  ReplyNext;                 /* Next msg in reply chain */
    #     UINT32  DateWritten;               /* When msg was written */
    #     UINT32  DateReceived;              /* When msg was received/read */
    #     UINT32  DateProcessed;             /* When msg was processed by packer */
    #     UINT32  MsgNum;                    /* Message number (1-based) */
    #     UINT32  Attribute;                 /* Msg attribute, see "Status bits" */
    #     UINT32  Attribute2;                /* Reserved for future use */
    #     UINT32  TxtOffset;                 /* Offset of text in text file */
    #     UINT32  TxtLen;                    /* Length of message text */
    #     UINT32  PasswordCRC;               /* CRC-32 of password to access msg */
    #     UINT32  Cost;                      /* Cost of message */
    # }

    count = 0

    class MSGHDR:
      pass

    fmtmhdr = "<4s2H17L"
    fmtmhdr_s = struct.calcsize(fmtmhdr)

    while True:
        
        msg = dict()

        #store hdr offset before read
        msg['hdr_offset'] = jhrf.tell()

        msgstr = jhrf.read(fmtmhdr_s)
        l = len(msgstr)
        if l != fmtmhdr_s:
            if l > 0:
              print "Error: %d extranious bytes at end of file", l
            break
    
        mh = MSGHDR()
        ( mh.Signature
        , mh.Revision
        , mh.ReservedWord
        , mh.SubfieldLen
        , mh.TimesRead
        , mh.MsgIdCRC
        , mh.ReplyCRC
        , mh.ReplyTo
        , mh.Reply1st
        , mh.ReplyNext
        , mh.DateWritten
        , mh.DateReceived
        , mh.DateProcessed
        , mh.MsgNum
        , mh.Attribute
        , mh.Attribute2
        , mh.TxtOffset
        , mh.TxtLen
        , mh.PasswordCRC
        , mh.Cost ) = struct.unpack(fmtmhdr, msgstr)

        #msg['hdr_sf'] = last_pos     
        #msg['msg_date']     = TimeStr(mh.DateWritten)
        #msg['msg_number']   = mh.MsgNum
        msg['attribute']    = mh.Attribute
        #msg['txt_start']    = mh.TxtOffset     #no longer necessary when using msg_gettxt from mysticbbs
        #msg['txt_len']      = mh.TxtLen        #no longer necessary when using msg_gettxt from mysticbbs

        class SUBFIELD:
            pass

        b = 0
        subfieldstr = jhrf.read(mh.SubfieldLen)
        
        fmtsf = "<2HL"
        fmtsf_s = struct.calcsize(fmtsf)
        while b < mh.SubfieldLen:
            sf = SUBFIELD()
            (sf.LoID, sf.HiID, sf.DatLen) = struct.unpack(fmtsf, subfieldstr[b:b + fmtsf_s])
            b += fmtsf_s
            sf.Buffer = subfieldstr[b:b + sf.DatLen]
            b += sf.DatLen
            sftype = SUBFIELDTYPES[sf.LoID] if sf.LoID in SUBFIELDTYPES else "Undefined"

            #if sftype == "SUBJECT":                
            #    msg['msg_subject'] = sf.Buffer
            #if sftype == "SENDERNAME":
            #    msg['msg_from'] = sf.Buffer             
            if sftype == "RECVRNAME":
              msg['msg_to'] = sf.Buffer

        # if not deleted or nulled (by editmsg in mystic)
        if (not bool(STATUSBITS['MSG_DELETED'] & msg['attribute']) 
            and not bool(STATUSBITS['MSG_REMOVED'] & msg['attribute'])
            and not bool(STATUSBITS['MSG_NODISP'] & msg['attribute'])
        ): # and msg['attribute'] != 0:
          try:
            if user["handle"] == msg['msg_to'] or user["name"] == msg['msg_to']:
              count = count + 1
          except:
            pass

    #print
    #return (msg_sf_end,msg,MessageNumber,msgs_subflds,Offset, Offset+TxtLen)
    return count


def count_msgs(file):
    #fileNameHdr = mbbs_msgs_dir + "/" + mbbs_msgs_base + ".jhr"
    #jhrf = open(fileNameHdr, "rb")
    file = file+".jhr"
    jhrf = open(file, "rb")

    get_msg_base_hdr(jhrf)
    count = raw_get_msgs(jhrf)

    jhrf.close()
    return count
"""

#------------------------------------------------------------------------------
def get_new_mail_count(recount=False):
  global user
  global mailbases
  global msgs
  global file

  if 'YOU' in actions and not 'NEW' in actions:
    #show loading stats
    write('|#X#2##20#6#60#10#')
    write("|[X22|[Y08|15Indexing message bases, hold on .. ")
    flush()    

  #loop indexed mailareas  
  for i in range(len(mailbases)):
    base = mailbases[i]
    mailbase = getmbaseid(base['id'])
      
    #logerror(str(mailbase))
    #set this to make sure get_msgs knows what to do
    #TODO: THIS CAUSED ISSUES
    #user['mbase'] = base['id']

    new = 0    
    total = 0

    if mailbase == None:
      msgdialog(' Error ','Msgbase not found!')
      return

    file = mailbase['path']+mailbase['filename'] #no extension
      
    msgs    = []
    msgbase = msg_open(file)




    #---------------------------------------------
    #ADD CUSTOM INDEXING TO READ COUNTS
    count = 0

    #ODDITY
    if 'NEW' in actions:
      mailbases[i]['total'] = count


    #if 'NEW' not in actions and (mailbase['nettype'] == 0 or mailbase['nettype'] == 3 or 'YOU' in actions):
    if 'NEW' not in actions and (bool(mailbase['flags'] & MB_Private) or 'YOU' in actions):
      #if private/email/netmail or YOU count posts to user
      #changed to IF PRIVATE
      if recount == False:          

        msg_seek(msgbase, -1) 
        while msg_found(msgbase) and not shutdown():

          msghdr = msg_gethdr(msgbase)
          #if user["handle"].upper() == msghdr['to'].upper() or user["name"].upper() == msghdr['to'].upper():
          #  count = count + 1
          if 'NOFROM' in actions:
            if user["handle"].upper() == msghdr['to'].upper() or user["name"].upper() == msghdr['to'].upper():
              count = count + 1
          else:
            if user["handle"].upper() == msghdr['to'].upper() or user["name"].upper() == msghdr['to'].upper() or user["name"].upper() == msghdr['from'].upper() or user["handle"].upper() == msghdr['from'].upper():
              count = count + 1

          msg_next(msgbase)

        # only set YOU total count once on first run
        mailbases[i]['total'] = count


    # get lastread      
    lr = msg_getlr (msgbase, user['id'])   

    # get stats
    total, new, yours, lastpost = msg_stats(msgbase)
    #gotoxy(2,2)
    #write(str(msg_stats(msgbase)))
    #write('|PN')

    # set stats
    #if mailbase['nettype'] == 0 or mailbase['nettype'] == 3: #or 'YOU' in actions:
    if bool(mailbase['flags'] & MB_Private):
      mailbases[i]['new'] = yours #new is incorrect!
      #mailbases[i]['total'] = total #removed to give accurate total when viewing own messages
    else:
      if 'YOU' in actions:
        mailbases[i]['new'] = yours
        #mailbases[i]['total'] = total #removed to give accurate total when viewing own messages
      else:
        mailbases[i]['new'] = new
        mailbases[i]['total'] = total




    msg_close(msgbase)
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def purge_areas():
  global user
  global mailbases
  global msgs
  global actions
  global file

  newbases = []

  for i in range(len(mailbases)):

    if 'ALL' in actions:
      newbases.append(mailbases[i])

    #if 'YOU' in actions and 'NEW' not in actions and mailbases[i]['total'] != 0: #gives problem when mail is read-- no new mail is left
    #elif 'YOU' in actions and mailbases[i]['total'] != 0:

    # NEW
    elif 'NEW' in actions and mailbases[i]['new'] != 0:
      newbases.append(mailbases[i])

    # YOU & !NEW
    elif 'YOU' in actions and not 'NEW' in actions: # and mailbases[i]['total'] != 0:
      newbases.append(mailbases[i])

    # !YOU & !NEW
    elif 'NEW' not in actions and 'YOU' not in actions:
      newbases.append(mailbases[i])

  mailbases = newbases
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
def get_subscriptions():
  #global user
  global mailbases

  #loop indexed mailareas  
  for i in range(len(mailbases)):
    base = mailbases[i]

    #if base['id'] != email_base:
    mailbase = getmbaseid(base['id'])
    
    #TODO: WHAT ABOUT THIS?!
    #DISABLED TO MAKE CHANGEAREA WORK WITHOUT CURRENT_MBASE
    #set this to make sure get_msgs knows what to do
    #user['mbase'] = base['id']

    if mailbase == None:
      msgdialog(' Error ','Msgbase not found!')
      return
    
    file = mailbase['path']+mailbase['filename'] #no extension
    #basename = mailbase['filename'].upper()

    mailbases[i]['subbed'] = read_msgbase_subscription(base['id'], file)[0]
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def loadmainlist(count=False):
  global mailbases
  global mailgroups
  global viewmode
  #global user

  if count==False:
    get_mailbases()

  get_subscriptions()


  get_new_mail_count(count)
  purge_areas()

  res = []

  # loop groups
  for i in range(len(mailgroups)):
    if access(mailgroups[i]['acs']):

      count = 0        
      areas = []    

      #loop areas
      for j in range(len(mailbases)):
        ma_group = getgroupfromacs(mailbases[j]['listacs'])            
        
        if ma_group == mailgroups[i]['id']: 

          #add base   
          if 'ALL' in actions or viewmode == "ALL" or mailbases[j]['subbed'] > 0:          
            count += 1
            #type>mbase
            #acs>listacs
            #groupid>id of group
            #target>id of base
            mailbases[j]['type'] = 'mbase'
            mailbases[j]['group'] = mailgroups[i]
            mailbases[j]['groupid'] = mailgroups[i]['id']
            mailbases[j]['target'] = mailbases[j]['id']
            areas.append(mailbases[j])

      #add group
      if count > 0:    
        res.append({'name':mailgroups[i]['name'],'type':'group','acs':mailgroups[i]['acs']})   #,'target':filegroups[i]['id']
        res += areas


  #loop again for fileareas without parent groups
  for j in range(len(mailbases)):        
      ma_group = getgroupfromacs(mailbases[j]['listacs'])      
      if ma_group == -1:

        #add base
        if 'ALL' in actions or viewmode == "ALL" or mailbases[j]['subbed'] > 0:          
          mailbases[j]['type'] = 'mbase'
          mailbases[j]['groupid'] = mailgroups[i]['id']
          mailbases[j]['target'] = mailbases[j]['id']
          res.insert(0,mailbases[j])


  return res
#------------------------------------------------------------------------------


###################################################################################################################
# Message base functions
###################################################################################################################


#------------------------------------------------------------------------------
#def set_bit(v, index, x):
#  #"""Set the index:th bit of v to 1 if x is truthy, else to 0, and return the new value."""
#  mask = 1 << index   # Compute mask, an integer with just bit 'index' set.
#  v &= ~mask          # Clear the bit indicated by the mask (if x is False)
#  if x:
#    v |= mask         # If x was True, set the bit indicated by the mask.
#  return v            # Return the result, we're done.
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def delete_msg_num(index, msg):
  global user
  global file
  global msgbase

  msg_seek(msgbase, int(msg['msg_number'])) 
  msghdr = msg_gethdr(msgbase)
    
  #double check! seek should get correct index, but with message number check we are sure
  if int(msghdr["number"]) == msg['msg_number']:
    msg_delete(msgbase)    
#------------------------------------------------------------------------------  


#------------------------------------------------------------------------------
def get_last_read_msg_num():
  global user
  global msgbase

  lr = msg_getlr (msgbase, user['id'])

  return lr
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def write_last_read_msg_num(msg_num,force=False):
  global user
  global msgbase

  msg_setlr (msgbase, user["id"], user["handle"], msg_num)
  
  return msg_num
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def read_msgbase_subscription(mbaseid, file):  
  global user

  fmtlr = "<LBB"
  fmtlr_s = struct.calcsize(fmtlr)

  fileNameSub = file+".scn"

  #there must be a better way?
  if os.path.isfile(fileNameSub) == False:
    f = open(fileNameSub, 'wb')
    f.close()

  jlrf = open(fileNameSub, "r + b")

  class MSGLR:
    pass
  
  offset      = 0
  newscan     = -1
  qwkscan     = 1

  lr = MSGLR()

  while True:
    offset = jlrf.tell()
    msgstr = jlrf.read(fmtlr_s)
    l = len(msgstr)
    if l != fmtlr_s:
      if l > 0:
        print "Error: %d extranious bytes at end of file", l
      break
    
    ( lr.UserID
    , lr.NewScan
    , lr.qwkscan ) = struct.unpack(fmtlr, msgstr)

    #if userid match
    if lr.UserID == user['id']:
      newscan = lr.NewScan
      qwkscan = lr.qwkscan
      break
    
  #close file
  jlrf.close()

  #if no custom newscan found
  if newscan == -1:
    #try to find default value in mbase
    base = getmbaseid(mbaseid)
    newscan = base['defnscan']

  #no id found, offset 0
  return newscan, qwkscan, offset
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def write_msgbase_subscription(mbaseid, newscan):

  global user

  mailbase = getmbaseid(mbaseid)
  file = mailbase['path']+mailbase['filename'] #no extension
  
  fmtlr = "<LBB"
  fmtlr_s = struct.calcsize(fmtlr)

  #initialize
  current_newscan, qwkscan, offset = read_msgbase_subscription(mbaseid, file)

  fileNameSub = file+".scn"
  jlrf = open(fileNameSub, "r + b")
  jlrf.seek(offset)
  
  #default new record
  msgstr = struct.pack(fmtlr, user['id'], newscan, qwkscan)

  jlrf.write(msgstr)
  jlrf.close()
  
  return read_msgbase_subscription(mbaseid, file)[0]
#------------------------------------------------------------------------------


def onlyascii(char):
    if ord(char) < 32 or ord(char) > 127: return ''
    else: return char

def get_my_string(data):
    filtered_data=filter(onlyascii, data)
    #filtered_data = filtered_data.lower()
    return filtered_data

#------------------------------------------------------------------------------
def processmsg(msghdr):
  global user
  global mailbase
  global mailbases
  global actions

  msg = dict()

  add = False

  if msghdr['deleted'] == False and msghdr['from'] != '':

    # determine from/to only in netmail/email/private OR when YOU is selected
    #if mailbase['nettype'] == 0 or mailbase['nettype'] == 3 or 'YOU' in actions:
    if bool(mailbase['flags'] & MB_Private) or 'YOU' in actions:
      
      # only index subbed mailbases, for efficiency
      index = False
      for i in range(len(mailbases)):
        if mailbases[i]['id'] == mailbase['id'] or mailbases[i]['subbed'] == 1: 
          index = True
      
      if index:
        if 'NOFROM' in actions:
          if user["handle"].upper() == msghdr['to'].upper() or user["name"].upper() == msghdr['to'].upper():
            add = True
        else:
          if user["handle"].upper() == msghdr['to'].upper() or user["name"].upper() == msghdr['to'].upper() or user["name"].upper() == msghdr['from'].upper() or user["handle"].upper() == msghdr['from'].upper():
            add = True
    else:
      add = True


    if add == True:

      msg['msg_date']     = TimeStr(msghdr['date'])
      msg['msg_number']   = msghdr['number']
      msg['msg_subject']  = re.sub(r'\s+', ' ',get_my_string(msghdr['subj']))
      msg['msg_from']     = re.sub(r'\s+', ' ',get_my_string(msghdr['from'])).strip()
      msg['msg_to']       = re.sub(r'\s+', ' ',get_my_string(msghdr['to'])).strip()

      return msg, True

  return msg, False 
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def load_prevmsg(index):
    global file
    global msgs
    global msg_count
    global msgbase

    msg_seek(msgbase, int(index)) 

    while msg_found(msgbase) and not shutdown():      
      msghdr = msg_gethdr(msgbase)
      msg, add = processmsg(msghdr)

      if add:
        if len(msgs) == 0 or msgs[0]['msg_number'] <> msg['msg_number']:
          msgs.insert(0,msg)
          msg_count += 1
          return True          
      msg_prev(msgbase)       

    return False
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def load_nextmsg(index):
    global file
    global msgs
    global msg_count
    global msgbase

    msg_seek(msgbase, int(index)) 

    while msg_found(msgbase) and not shutdown():
      
      msghdr = msg_gethdr(msgbase)
      tmpid = int(msghdr['number'])
      msg, add = processmsg(msghdr)

      if add:
        if len(msgs) == 0 or msgs[len(msgs)-1]['msg_number'] <> msg['msg_number']:
          msgs.append(msg)
          msg_count += 1
          return True
      msg_next(msgbase)       

    return False
#------------------------------------------------------------------------------

    
#------------------------------------------------------------------------------
def get_msgs(index=-1):
    global msg_count
    global msgs
    global msg_lastID
    global msgbase
    
    global hdrlines 

    msgs      = []
    msg_count = 0
    msg_index = 0 

    if msgbase is None:
      quit()

    msg_seek(msgbase, 0) 
    msghdr = msg_gethdr(msgbase)
    msg_lastID = msghdr['highmsg']

    lr = get_last_read_msg_num() 
    if index == -1:
      index = lr #start at last read position
    
    msg_seek(msgbase, index)    

    #bugfix!
    #this fixes the problem if last message has been deleted (making highmsg incorrect)    
    bugfix = 0
    if bugfix == 0 and index == msg_lastID: 
      msghdr = msg_gethdr(msgbase)    
      if int(msghdr['number']) <> int(msg_lastID):
        msg_prev(msgbase)
   
    count = 0
    while msg_found(msgbase) and count <= hdrlines and not shutdown():
      msghdr = msg_gethdr(msgbase)    
      msg, add = processmsg(msghdr)
      #set mbaseid in msg for dynamic headers
      #msg['mbase'] = mbaseid

      if add:
        if len(msgs) == 0 or msgs[0]['msg_number'] <> msg['msg_number']:
          msgs.insert(0,msg)
          msg_count += 1
          count += 1
      msg_prev(msgbase)       
    
    ## read messages forward
    msg_seek(msgbase, index) 
    count = 0
    while msg_found(msgbase) and count <= hdrlines and not shutdown():
      msghdr = msg_gethdr(msgbase)
      msg, add = processmsg(msghdr)
      #set mbaseid in msg for dynamic headers
      #msg['mbase'] = mbaseid

      if add:
        if len(msgs) == 0 or msgs[len(msgs)-1]['msg_number'] <> msg['msg_number']:
          msgs.append(msg)
          msg_count += 1
          count += 1
      msg_next(msgbase)       
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def get_msg_body(index,msg,echohdr=False):

    global user
    global file
    global msgbase

    if msgbase is None:
      quit()

    msg_seek(msgbase, int(msg['msg_number'])) 
    msghdr = msg_gethdr(msgbase)
    
    #double check! seek should get correct index, but with message number check we are sure
    if msghdr["number"] == int(msg['msg_number']):
      newtxt = []
      msgtxt = msg_gettxt(msgbase)

      #remove echomail information        
      if echohdr == False:
        for i in range(len(msgtxt)):
          if msgtxt[i].find("") != 0:
            newtxt.append(msgtxt[i])
      else:
        newtxt = msgtxt

      #concat dict into one string
      #\n\r = double cariage in ascii
      #\n = no enters in ascii
      msgbody = '\r'.join(newtxt)

    return msgbody
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def index_msgs(mbaseid,index=-1):
    global cfg
    global user
    global file
    #global basename
    global msgbase

    base = getmbaseid(mbaseid)
    #gotoxy(1,1)
    #writeln(str(base))
    #write('|PA')
    

    if user == None:
        msgdialog(' Error ','User not found!')
        return  

    file = base['path']+base['filename'] #no extension
    #basename = base['filename'].upper()

    if base == None:
      msgdialog(' Error ','Msgbase not found!')
      return
    
    #this could cause issues if private base has some extended acs requirements
    #if access(base['listacs']) or mbaseid in config.private_bases:
    if access(base['listacs']) or (base['nettype'] == 0 and bool(base['flags'] & MB_Private)):
      msgbase = msg_open(file)
      get_msgs(index)
#------------------------------------------------------------------------------
    

##########################################################################################################################
# Regex 
##########################################################################################################################

#------------------------------------------------------------------------------
def regex_replace(s,keyarray):
  for match in re.findall(r'\%\w+', s):

    s = re.sub(match, keyarray[re.sub(r'\%','',match)], s)

  return s
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
def mci_adjust_y(s,i=0):
  for match in re.findall(r'\|\[Y([0-9]{2})', s):
    pos = int(match)
    pos += i
    s = s.replace('|[Y'+match, '|[Y'+str(pos).zfill(2)) 

  return s
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def mci_adjust_x(s,i=0):
  for match in re.findall(r'\|\[X([0-9]{2,3})', s):
    pos = int(match)
    pos += i
    s = s.replace('|[X'+match, '|[X'+str(pos).zfill(2)) 

  return s
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def mci_extract_y(s):
  for match in re.findall(r'\|\[Y([0-9]{2})', s):
    pos = int(match)
    return pos

  return -1
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def mci_extract_x(s):
  for match in re.findall(r'\|\[X([0-9]{2,3})', s):
    pos = int(match)
    return pos

  return -1
#------------------------------------------------------------------------------


##########################################################################################################################
# Draw message body
##########################################################################################################################

def color_code_to_ansi(input_string, combine_space=False, lastfgcolor=None, lastbgcolor=None, lastintensity=None):

    #global last_applied_bg, last_applied_intensity
    # ANSI color codes mapping
    foreground_colors = {
        "00": "30", "01": "34", "02": "32", "03": "36", "04": "31", "05": "35",
        "06": "33", "07": "37", "08": "30", "09": "34", "10": "32", "11": "36",
        "12": "31", "13": "35", "14": "33", "15": "37"
    }

    background_colors = {
        "16": "40", "17": "44", "18": "42", "19": "46", "20": "41", "21": "45",
        "22": "43", "23": "47"
    }

    # Regex to find color codes
    color_pattern = re.compile(r"\|(\d{2})")

    # Initialize default colors
    current_fg = lastfgcolor
    current_bg = lastbgcolor
    current_intensity = lastintensity  # Default intensity is normal
    #last_applied_bg = lastbgcolor #"40"
    #last_applied_intensity = lastintensity
    result = ""
    buffer = ""

    def apply_color(fg, bg, intensity):
        """Generate ANSI code based on current foreground, background, and intensity."""
        #global last_applied_bg, last_applied_intensity

        parts = []
        #if intensity and intensity != last_applied_intensity:

        if intensity != None:
          parts.append(intensity)
        #last_applied_intensity = intensity
        #if fg:
        if fg != None:
          parts.append(fg)
        #if bg and bg != last_applied_bg:

        if bg != None:
          parts.append(bg)

        #last_applied_bg = bg
        #if parts == None:
        #write(str(parts))
        if intensity or fg or bg:
          return "\033[" + ";".join(parts) + "m" #if parts else ""
        
        return ""

    def replace_spaces_with_cursor_move(text):
        """Replace multiple spaces with ANSI cursor movement."""
        def space_replacer(match):
            spaces = len(match.group(0))
            return "\033[{}C".format(spaces)

        return re.sub(r" {3,}", space_replacer, text)

    # Parse the input string
    for i, part in enumerate(re.split(r"(\|\d{2})", input_string)):
        next_char_index = input_string.find(part) + len(part)
        next_char = input_string[next_char_index:next_char_index + 1] if next_char_index < len(input_string) else ""

        if color_pattern.match(part):
            color_code = part[1:]

            if color_code in foreground_colors:
                fg_ansi = foreground_colors[color_code]

                new_intensity = "1" if int(color_code) >= 8 else "0"  # High intensity for codes 8-15
                if fg_ansi != current_fg or new_intensity != current_intensity:
                    # Flush buffer with the current color if fg or intensity changes
                    if buffer:
                        result += apply_color(current_fg, current_bg, current_intensity) + buffer
                        buffer = ""
                    current_fg = fg_ansi
                    current_intensity = new_intensity
            elif color_code in background_colors:
                bg_ansi = background_colors[color_code]
                if bg_ansi != current_bg:
                    # Flush buffer with the current color if bg changes
                    if buffer:
                        result += apply_color(current_fg, current_bg, current_intensity) + buffer
                        buffer = ""
                    current_bg = bg_ansi
        else:
            # Replace multiple spaces with cursor movement
            if combine_space:
              part = replace_spaces_with_cursor_move(part)

            # Add text to buffer
            buffer += part

    # Flush any remaining buffer
    if buffer:
        result += apply_color(current_fg, current_bg, current_intensity) + buffer

    #removed +'\n'
    return result, current_fg, current_bg, current_intensity


#------------------------------------------------------------------------------
def multiple_replace(string, rep_dict):
    pattern = re.compile("|".join([re.escape(k) for k in sorted(rep_dict,key=len,reverse=True)]), flags=re.DOTALL)
    return pattern.sub(lambda x: rep_dict[x.group(0)], string)
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def draw_msg_body(msg,index,top=0,dumpquote=False,echohdr=False):
  
  global old_body_top
  global cfg
  global user
  global debug

  #required to avoid loading drawmsg on each call
  #todo: move body to msgs['body']
  global msgtext
  global msglines
  global plaintext

  #msglines = None

  ansitext = False
  #get quote name (first two letters or if spaces first two word letters)
  #used for message quote dump
  quote_to    = get_quote_from_name(msg['msg_to'])
  quote_from  = get_quote_from_name(msg['msg_from']) 

  if msgtext == None or dumpquote == True:
    #reset old position
    old_body_top = -1

    msgtext = get_msg_body(index,msg,echohdr)
    msgtext = multiple_replace(msgtext, config.rep)
    #instead of here we do that on drawing
    #msgtext = color_code_to_ansi(msgtext,False)[0]
    msgtext = utf_to_ascii( msgtext )

    #fixes cnet color string lengths, loses body
    
    #bugfix, this makes cnet color codes to mci fix strln
    #to show only two colors
    #msgtext = stripmcicolor(msgtext)
    if ansi_escape.search(msgtext) != None:
        ansitext = True

    if ansitext:
      msgtext, plaintext = ansi2mci(msgtext,dumpquote)
      newtext = []
      fgcolor = None
      bgcolor = None
      intensity = None
      for line in msgtext:
        tmpline,fgcolor, bgcolor, intensity = color_code_to_ansi(line, False, fgcolor, bgcolor, intensity)
        newtext.append(tmpline)
        #newtext.append(line)

      msgtext = newtext
      #msgtext = ""
      #msgtext = ansi2mci('/mystic/themes/default/text/test1.ans',dumpquote,True)    
      #msgtext = ansi2mci('/mystic/themes/default/text/ungenannt-darkness.ans',dumpquote,True)
    else:
      msgtext = msgtext.splitlines()
      
      splittext = []
      for i in range(len(msgtext)):

        if len(stripmcicolor(msgtext[i])) < 79:
          splittext.append( msgtext[i])
        else:
          # try to truncate
          count = 0
          prefix = ""
          if msgtext[i].strip()[:15].rfind('>') > -1:
            prefix = msgtext[i][:msgtext[i][:15].rfind('>') + 1] + ' '

          #truncate and add quotemarks where needed
          while len(msgtext[i]) > 80:          
            spacepos = msgtext[i][:80].rfind(' ')
            if spacepos < (80 - 20) or spacepos == -1:
              spacepos = 79

            if count == 0:
              splittext.append( msgtext[i][:spacepos] )
            else:
              splittext.append( prefix + msgtext[i][:spacepos] )
            msgtext[i] = str(msgtext[i][spacepos+1:])

            count += 1

          if count > 0:
            splittext.append( prefix + msgtext[i])
          else:
            splittext.append( msgtext[i])

      msgtext = splittext

      #convert each line to plaintext
      plaintext = []
      for line in msgtext:
        plaintext.append(stripmcicolor(line))

    msglines = len(msgtext)

  if dumpquote == True:
    
    #dump body as quote
    msgtmpf = cfg['temp']+'msgtmp'
    f = open(msgtmpf,'w')
    for i in range(len(msgtext)):
        
      if not ansitext:
        #add newline
        f.write(' '+quote_from+'> '+stripmcicolor(msgtext[i])+'\r')
      else:
        f.write(' '+quote_from+'> '+msgtext[i])
        #f.write(' '+quote_from+'> '+color_code_to_ansi(msgtext[i])[0])
    return 

  else:
          
    #draw body
    if top >= msglines-config2.getint('body','max_body_lines'): #config.max_body_lines:
      top = msglines-config2.getint('body','max_body_lines')

    if top < 0:
      top = 0


    if old_body_top <> top:
      updatebar.bar_oldpos_x = -1
      updatebar(config2.get('body','body_bar_start'), top, msglines-config2.getint('body','max_body_lines'), config2.getint('body','max_body_lines'), False)

      start_y = mci_extract_y(config2.get('body','msg_body_startpos'))
      start_x = mci_extract_x(config2.get('body','msg_body_startpos'))
      #this was to make sure msg_body_startpos works without |[Yxx
      #start_y = mci_extract_y(mci_adjust_y(config2.get('reader','startpos'),config2.getint('reader','max_header_lines')+3))

      #calculate offset when bodylines < max_bodylines
      offset = 0
      if config2.getboolean('body','center_message'):
        if msglines < config2.getint('body','max_body_lines'):
          offset = (config2.getint('body','max_body_lines')-msglines) / 2
          start_y += offset
          #clear lines up to offet
          for i in range(0,offset):
            gotoxy(start_x,start_y+i-offset)
            write(config.msg_body_clearstr)
      

      old_body_top = top

      j = 0
      while j<config2.getint('body','max_body_lines')-offset and start_y != -1:

        #posy = mci_extract_y(config.msg_body_startpos,j)      
        gotoxy(start_x,start_y+j)
        #write(pos)

        #write(config.msg_body_default)
        #gotoxy(1, start_y+j+top)
        
        # draw msg body
        if j+top<msglines:

          plain = False
          trim = False
          
          # check if highlight variations
          if j == 0 and plaintext[j+top].strip()[:3].upper().find('-=>') == 0:
            write(config.msg_body_low)
            plain = True
            #trim = True
          elif plaintext[j+top].strip()[:3].find('>') > -1:
            write(config.msg_body_quote_highlight)
            plain = True
          elif j == 0 and plaintext[j+top].strip()[:3].upper().find('ON ') == 0:
            write(config.msg_body_low)
            plain = True
          elif j < 3 and plaintext[j+top].strip()[:3].upper().find('BY:') in [0,1]:
            write(config.msg_body_low)
            plain = True
            trim = True
          elif j < 2 and plaintext[j+top].strip()[:3].upper().find('RE:') in [0]:
            write(config.msg_body_low)
            plain = True
            trim = True
          elif j < 2 and plaintext[j+top].strip()[:17].upper().find('QUOTING MESSAGE ') > -1:
            write(config.msg_body_low)
            plain = True
          elif j == 1 and plaintext[j+top].strip()[:3].upper().find('ON ') == 0:
            write(config.msg_body_low)
            plain = True
          elif j+top > msglines-3 and plaintext[j+top].lstrip()[:4].find('---') > -1:
            write(config.msg_body_low)
            plain = True
          elif j+top > msglines-4 and plaintext[j+top].lstrip()[:4].find('--- ') > -1:
            write(config.msg_body_low)
            plain = True
          elif j+top > msglines-4 and plaintext[j+top].lstrip()[:4].find('*** ') > -1:
            write(config.msg_body_low)
            plain = True
          elif j+top > msglines-4 and plaintext[j+top].lstrip()[:4].find('[+] ') > -1:
            write(config.msg_body_low)
            plain = True
          elif j+top > msglines-6 and plaintext[j+top].lstrip()[:4].find(chr(254)) > -1:
            write(config.msg_body_low)
            plain = True
          elif j+top > msglines-6 and plaintext[j+top].lstrip()[:4].find('... ') > -1:
            write(config.msg_body_low)
            plain = True
          elif j+top > msglines-4 and plaintext[j+top].lstrip()[:4].find('=== ') > -1:
            write(config.msg_body_low)
            plain = True
          elif j+top > msglines-6 and plaintext[j+top].lstrip()[:2].find('* ') > -1:
            write(config.msg_body_low)
            plain = True
          else:
            write(config.msg_body_default)

            #TODO: add OR only alpha numeric chars
            #if is_unicode_alnum_or_punct(plaintext[j+top]):
            #  plain = True
            if ansi_escape.search(msgtext[j+top]) == None: 
              if len(stripmcicolor(msgtext[j+top])) == len(msgtext[j+top]):
                plain = True
          
          #if j+top<msglines-5:

          #if forced plaintext
          #or length plaintext equals msgtext
          if plain: # or (not ansitext and len(stripmcicolor(msgtext[j+top])) == len(msgtext[j+top])):
            if trim:
              rwrite(stripmcicolor(plaintext[j+top][:80]).lstrip())
            else:
              rwrite(stripmcicolor(plaintext[j+top][:80]))
          else:
            #rwrite(msgtext[j+top])
            pwrite(color_code_to_ansi(msgtext[j+top],False)[0])
            #write(' ')
            #write(config.msg_body_clearstr)  
          #else:
          #  write(msgtext[j+top])

        # clear line until end of config.max_body_lines
        if wherey()==j+start_y:      
          write(config.msg_body_clearstr)

        j+=1

  #msg_text = None
  return top
#------------------------------------------------------------------------------

######################################################################################################################
# Defs
######################################################################################################################

def find_display_custom( filepath ):
    """ load ansi file with backwards compatibility for mystic a47 or lower """    
    try:
      find_display('test')
    except AttributeError as e:
        
        x, y = bbs.termsize();

        base = filepath[:-4] 

        if os.path.exists(base + '.c' + str(x) + 'x' + str(y) + '.ans'):
            return base + '.c' + str(x) + 'x' + str(y) + '.ans'
        elif os.path.exists(base + '.c' + str(x) + '.ans'):
            return base + '.c' + str(x) + '.ans'
        else:
            return filepath

    else:        
        return find_display( filepath[:-4] )            


#------------------------------------------------------------------------------
def drawbackground():
  
  reader_ansi = find_display_custom(rjamdir+config2.get('ansi','reader'))
  showfile(reader_ansi,0,0,0,0)
    
  #write(config.reader_initscreen)  
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
def drawtreelist():
  #write('|16|CL')
  group_ansi = find_display_custom(rjamdir+config2.get('ansi','group'))
  showfile(group_ansi,0,0,0,0)
  #write(config.mg_initscreen)
#------------------------------------------------------------------------------


################################################################################################################################
# Treelist 
################################################################################################################################

#------------------------------------------------------------------------------
def set_area():
    global items
    global actions
    global user

    i = 0    
    selbar = 0
    top = 0
    found = False

    # set mbase according to initial (or returning group)
    while i<len(items) and found == False:
      if items[i]['type'] != 'group':
        #TODO: global user and use user['mbase'] instead! besides, current_mbase wasnt defined as global?!
        #if (items[i]['new'] != 0 and 'NEW' in actions) or ('NEW' not in actions and int(items[i]["target"]) == int(current_mbase)):
        if (items[i]['new'] != 0 and 'NEW' in actions) or ('NEW' not in actions and int(items[i]["target"]) == int(user['mbase'])):
        #gotoxy(1,2)
        #writeln(str(user['mbase']))
        #write('|PA')
        #if (items[i]['new'] != 0 and 'NEW' in actions) or ('NEW' not in actions and int(items[i]["target"]) == 13):
          #wrinteln(str(actions))
          selbar = i
          found = True
      i += 1
    
    #find first area if none was selected
    if selbar == 0:
      while items[selbar]['type'] == 'group' and selbar < len(items) - 1:  
        selbar += 1
    
    #adjust top to selbar position
    if selbar >= config2.getint('group','max_lines'): #config.mg_max_lines:      
      top = selbar - config2.getint('group','max_lines') 

    #adjust top to end in middle of available space
    if selbar > (config2.getint('group','max_lines') / 2 ):
      top = selbar - ( config2.getint('group','max_lines') / 2 );

    #make sure no gap at bottom
    if selbar > len(items)-config2.getint('group','max_lines'):
      top = len(items) - config2.getint('group','max_lines')

    if top < 0:
      top = 0

    return selbar, top
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def key_up(selbar, top):
  global items

  if selbar > 0:
    selbar=selbar-1    
  
  while items[selbar]['type'] == 'group':
      selbar -=1
      if selbar < 0:
        selbar = 1
        top = 0
  if selbar < top:
      top = selbar
      selbar = top
  
  return selbar, top
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def key_down(selbar, top):
  global items

  selbar+=1
  if selbar > len(items)-1:
      selbar = len(items)-1
      if items[selbar]['type'] == 'group':
          selbar -= 1
  else:
      while items[selbar]['type'] == 'group' and selbar < len(items) - 1:
          selbar +=1
          if selbar-top > config2.getint('group','max_lines') - 1:
              top += 1
      #precaution if last pos is an group
      while items[selbar]['type'] == 'group' and selbar > 0:
          selbar -= 1

  if selbar-top > config2.getint('group','max_lines') - 1:
      top += 1

  return selbar, top
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
def treelist():
    #global current_mbase
    global rjamdir
    global last_msg_num
    global user
    global items
    global msg_count
    global msgs
    global viewmode
    global mailbase
    global mailbases

    current_group_id = None

    #search_txt = ''
    #search_x = 12
    #search_y = 23
    #search_cl= 8

    if len(items)<1:
      return -1

    key = ""
    #value = -1
    done = False

    start_y     = mci_extract_y(config2.get('group','startpos')) #config.mg_startpos)
    #gotoxy(1,4)
    #writeln(str(user['mbase'])+"  ")
    #write('|PA')    
    selbar, top = set_area()

    oldtop = -1
    oldbar = -1
    redraw = True
    redraw_bg = True

    menucmd('NA','rJAM - Viewing Mailbases')
    sysoplog(1,'rJAM - Viewing Mailbases')


    #go straight to mailbase if only one base newmail!
    if(len(mailbases)) == 1:
      #gotoxy(1,1)
      #write(str(mailbases))
      #write('|PN')
      write('|CL')

      menucmd('MG',str(mailbases[len(mailbases)-1]['groupid']))
      menucmd('MA',str(mailbases[len(mailbases)-1]['id']))

      mailbase = getmbaseid(mailbases[len(mailbases)-1]['id'])        
      index_msgs(mailbases[len(mailbases)-1]['id'])
      last_msg_num = get_last_read_msg_num()
      #maillist(items[len(items)-1]['id'], items[len(items)-1]['total'], items[len(items)-1]['new'])
      # get stats
      #total, new, yours, lastpost = msg_stats(msgbase) 
      #TODO: update user['mbase']
      maillist(mailbases[len(mailbases)-1]['id'],mailbases[len(mailbases)-1]['total'],mailbases[len(mailbases)-1]['new'])
      #maillist(mailbases[len(mailbases)-1]['id'],len(msgs),mailbases[len(mailbases)-1]['new'])
      return

      #stuffkey(chr(13))
      #gotoxy(1,1)
      #write('hello|PA')
    

    while done == False and not shutdown():

        ma_group = items[selbar]['groupid']  
        if ma_group != -1:
          menucmd('MG',str(ma_group))
        
          #if items[selbar]['id'] != config.private_bases[0]:
          menucmd('MA',str(items[selbar]['id']))
        
        user['mbase'] = items[selbar]['id']   
        #current_mbase = items[selbar]['id']   #for when we return

        if redraw_bg == True:
            drawtreelist()
            redraw_bg = False

        #should add oldpos/selbar to redraw
        if oldbar <> selbar or oldtop <> top or redraw == True:
  
          redraw = False

          oldbar = selbar
          oldtop = top
            
          #update scrollbar
          #updatebar(config2.get('group','bar_start'), selbar, len(items), config2.getint('group','max_lines'), False)
          updatebar(config2.get('group','bar_start'), selbar+1, len(items), config2.getint('group','max_lines'), False, redraw)

          y = top
          while y-top<=config2.getint('group','max_lines') - 1:

              pos = mci_adjust_y(config2.get('group','startpos'),y-top)                    

              if y<len(items):
                  
                  #set prompt for use in display strings
                  setpinfo(8, '')        
                  #if items[y]['type'] == 'mbase':                    
                  #  if items[y]['subbed'] == 0:
                  #    if 'ALL' not in actions:
                  #      setpinfo(8, config.mg_str_unsubbed)        
                  
                  setpinfo(1, items[y]['name'])        

                  if items[y]['type'] == 'mbase':                    
                    if int(items[y]['total']) == 0 or int(items[y]['total']) == -1: # or items[y]['subbed'] == 0: dont hide total count
                      setpinfo(2, config.mg_no_new)
                    else:
                      setpinfo(2, str(items[y]['total']))      
                        
                    #only set if more than 0
                    if int(items[y]['new']) == 0:
                      setpinfo(3, config.mg_no_new)
                    else:
                      if items[y]['subbed'] == 0:                      
                        #color
                        color = '|08'
                        if selbar == y:
                          color = '|07'
                        
                        setpinfo(3, color+str(items[y]['new']))
                      else:
                        setpinfo(3, str(items[y]['new']))                      

                  #default display string
                  s = config2.get('group','area') #config.mg_str_area

                  #group display string
                  if items[y]['type'] == 'group':
                      s = config2.get('group','group') #config.mg_str_group

                  #highlight display string
                  elif selbar == y:
                    s = config2.get('group','area_high') #config.mg_str_highlight        

                    #additional messages if we want    
                    if items[y]['type'] == 'mbase':                        
                      write(config.mg_totalmsgs)
                      write(config.mg_newmsgs)

                  setpinfo(9, ' ')        
                  if items[y]['type'] != 'group':
                    if items[y]['subbed'] > 0 and items[y]['new'] > 0:            
                      setpinfo(9, config.mg_str_new)
                    elif items[y]['subbed'] == 0:
                      setpinfo(9, config.mg_str_unsubbed)

                      #s = config.mg_str_new+' '+s                    

                  write(pos)
                  write(s)
              else:
                   #fill empty
                   #need to test this!
                  write(pos)
                  write(config2.get('group','str_empty'))

              y += 1            

          #draw logo group
          if config2.getboolean('group','show_logo') and items[selbar]['groupid'] <> current_group_id:
            
            #if issysop():
            #  mailbase = getmbaseid(items[selbar]['id'])
            #  writeln('   '+str(mailbase)+'|PN')
            #  writeln('   '+str(cfg)+'|PN')
            

            groupname = ''.join(filter(str.isalnum, items[selbar]['group']['name'].lower()))
            ansi_file = find_display_custom(rjamdir+'art-group_'+groupname+'.ans')

            if ansi_file == None:
              ansi_file = find_display_custom(rjamdir+'group'+str(items[selbar]['groupid'])+'.ans')

            if ansi_file != None:

              ansi_data, ansi_plain = ansi2mci(ansi_file, False, True)
              current_group_id = items[selbar]['groupid']

              start_y_ansi = mci_extract_y(config2.get('body','msg_body_startpos'))
              start_x_ansi = mci_extract_x(config2.get('body','msg_body_startpos'))

              #calculate offset when bodylines < max_bodylines
              offset = 0
              if config2.getboolean('body','center_message'):
                if len(ansi_data) < config2.getint('body','max_body_lines'):
                  offset = (config2.getint('body','max_body_lines')-len(ansi_data)) / 2
                  start_y_ansi += offset
                  #clear lines up to offet
                  for i in range(0,offset):
                    gotoxy(start_x_ansi,start_y_ansi+i-offset)
                    write(config.msg_body_clearstr)
              
              #gotoxy(50,16)
              #write('|14'+str(current_group_id)+' '+ansi_file+' '+str(len(ansi_data)))
              #write(str(ansi_data))
              for i in range(0,len(ansi_data)):
                gotoxy(start_x_ansi,start_y_ansi+i)
                write(ansi_data[i])

              for i in range(len(ansi_data),config2.getint('body','max_body_lines')):
                gotoxy(start_x_ansi,start_y_ansi+i)
                write(config.msg_body_clearstr)




        #get keypress
        key, extended = getkey()       
        if extended:
      
          if key == KEY_UP:
              selbar, top = key_up( selbar, top )

          elif key == KEY_LEFT:
              #remember old position
              tmppos = selbar
              
              if selbar > 0:
                if items[selbar-1]['type'] != 'group':                
                  while items[selbar-1]['type'] != 'group' and selbar > 0:                    
                    selbar -= 1  
                elif selbar > 1:                  
                  selbar -= 2
                  while items[selbar]['type'] == 'group' and selbar > 0:  
                    selbar -= 1

                #return to old position if only groups found
                if items[selbar]['type'] == 'group':
                  selbar = tmppos

              #adjust top
              if selbar <= top and selbar != 0:
                  top = selbar - 1
                  selbar = top + 1

          elif key == KEY_RIGHT:
              #remember old position
              tmppos = selbar
              
              if selbar < len(items) - 1:
                if items[selbar+1]['type'] != 'group':
                  while selbar < len(items) - 1 and items[selbar+1]['type'] != 'group':  
                    selbar += 1  

                elif selbar < len(items) - 2:

                  selbar += 2
                  while items[selbar]['type'] == 'group' and selbar < len(items) - 1:  
                    selbar += 1

                #return to old position if only groups found
                if items[selbar]['type'] == 'group':
                    selbar = tmppos

              #adjust top
              if selbar > top + config2.getint('group','max_lines') - 1:
                  top = selbar - config2.getint('group','max_lines') + 1
             

          elif key == KEY_PGUP:
              selbar = selbar - config2.getint('group','max_lines')
              if selbar < 0:
                selbar = 0
              while items[selbar]['type'] == 'group':
                selbar +=1          
                
              top = top - config2.getint('group','max_lines')
              if top < 0:
                top = 0

          elif key == KEY_PGDN:
              selbar = selbar + config2.getint('group','max_lines')
              if selbar > len(items)-1:
                  selbar = len(items)-1
              top = top+config2.getint('group','max_lines')
              if top > len(items)-config2.getint('group','max_lines'):
                  top = len(items)-config2.getint('group','max_lines')
                  if top < 0:
                      top = 0
              if items[selbar]['type'] == 'group' and selbar < len(items) -1:
                  selbar +=1

              #added if prevent error if someones configuration is really really bad ;)
              if selbar == len(items) - 1:
                  while items[selbar]['type'] == 'group' and selbar > 0:
                      selbar -= 1


          elif key == KEY_END:
              selbar=len(items)-1
              if len(items)-config2.getint('group','max_lines') > 0:
                  top = len(items)-config2.getint('group','max_lines')
              else:
                  top = 0
              if items[selbar]['type'] == 'group':
                  selbar -=1

              #precaution to avoid incorrect selection if last pos is an group
              while items[selbar]['type'] == 'group' and selbar > 0:
                selbar -= 1

          elif key == KEY_HOME:
              selbar=0
              top = 0
              if items[selbar]['type'] == 'group':
                    selbar +=1

          elif key == KEY_DOWN: 
              selbar, top = key_down(selbar, top)
                      
        else:
          key = key.upper()          
          if key == KEY_ENTER or key == KEY_TAB:
              
              if "AREASELECT" in actions:   
                done = True

              else:

                #write('|SS')
                #wrtie('|#I#2#12#New Message Scan#Scanning: |&1...#')

                mailbase = getmbaseid(items[selbar]['id'])
                mailbase['groupid'] = items[selbar]['groupid']

                # index messages
                index_msgs(items[selbar]['id'])

                # initialize last message (first result from function)                
                last_msg_num = get_last_read_msg_num()

                #exit if no msgs (check here for when msgs get deleted)
                if msg_count == 0:    

                  #show dialog and exit
                  s = config.msg_no_messages.replace('|&1',mailbase['filename'].upper())
                  msgdialog(' Mail ',s)

                else:
                  #write(str(items[selbar]))
                  #write('|PN')
                  maillist(items[selbar]['id'],items[selbar]['total'],items[selbar]['new'])

                #clear messages
                msgs = []

                #update node status
                menucmd('NA','rJAM - Viewing Mailbases')
                #sysoplog(1,'rJAM - Reading Mailbases')

                # reload group/area
                # count only!
                items = loadmainlist(True)
                if len(items)==0:
                  done = True
                if selbar > len(items) - 1:
                  selbar = 1

                #write('|RS')
                #TODO: only redraw CURRENT position!
                redraw_bg = True
                redraw = True
                current_group_id = None

          elif key == KEY_CTRLA:

              # switch between subscriptions and all bases
              if viewmode == "ALL":
                msgdialog(' View ',config.view_sub_str)
                viewmode = "SUB"
              else:
                viewmode = "ALL"
                msgdialog(' View ',config.view_all_str)

              # reload bases
              items = loadmainlist(True)
              if len(items)==0:
                  done = True
              
              # reposition selection bar
              selbar, top = set_area()

              #drawbackground()
              redraw_bg = True
              redraw = True

          elif key == KEY_CTRLN:
            #TODO: current_mbase or items[selbar]['id']?
            #mailbase = getmbaseid(current_mbase)
            mailbase = getmbaseid(user['mbase'])
            mailbase['groupid'] = items[selbar]['groupid']

            write('|#X#2##20#6#60#10#')
            write('|[X22|[Y08|07Send to    |08[.......................]')
            write('|[X34|[Y08|15')

            #gotoxy(1,1)
            #write(str(mailbase['flags']))

            if mailbase['nettype'] == 1:
            #if not bool(mailbase['flags'] & MB_Private):
              to = getstr(11, 23, 23, "All")
            else:
              to = getstr(11, 23, 23, "")

            if to != None and len(to) > 1:

              to = to.replace(' ','_')  #spaces bug the receiver..

              write('|#X#2##10#6#70#10#')
              write('|[X12|[Y08|07Subject    |08[...........................................]')
              write('|[X24|[Y08')
              subject = getstr(11, 43, 43, "")

              if subject != None and len(subject) > 1:

                subject = subject.replace(' ','_')  #spaces bug the receiver..
                subject = subject.replace('/F','\F')  #/F is seen as /FORCED no matter what

                #only use MW on local mail and private base
                if mailbase['nettype'] == 0 and bool(mailbase['flags'] & MB_Private):
                
                  menucmd('MW','/to:'+to+' /subj:'+subject)
                else:
                #elif mailbase['nettype'] == 3 or mailbase['nettype'] == 1 or mailbase['flags'] == 68:
                  #netmail nettype == 3
                  write('|CL')
                  write('|IF')
                  menucmd('MP','/to:'+to+' /subj:'+subject)

            #drawbackground()
            #redraw_hdr = True  
            #redraw = True
            redraw_bg = True
            redraw = True
            current_group_id = None


          elif key == KEY_CTRLS:

            #TODO: 
            # - get search input
            # - index_search_msg(search string)
            # - maillist(-1, total found, 0 (newmsgs)) // never show newmsgs in search mode
            
            write(config.clearscr)
            menucmd('MS','C')

            redraw_bg = True
            redraw = True
            current_group_id = None
            #redraw_hdr = True
            #redraw = True
          
          elif key == KEY_CTRLP:
              write('|#X#2##09#12#69#16#|[Y12')

              today = (datetime.datetime.now()+datetime.timedelta(days=1)).strftime("%d%m%y")      
              stuffkey(today)
              write('|-N')
              menucmd('MD', '')

              write('|DE')

              # reload bases
              items = loadmainlist(True)

              redraw = True

          elif key == KEY_CTRLC:

              write('|#X#2##09#12#69#16#|[Y12')

              today = (datetime.datetime.now()+datetime.timedelta(days=1)).strftime("%d%m%y")      
              stuffkey(today)
              write('|-N')
              menucmd('MD', '')
              #menucmd('MD', '/ALL')

              write('|DE')

              # reload bases
              items = loadmainlist(True)

              redraw = True

          elif key == KEY_CTRLU:
              write('|SS')

              if items[selbar]['subbed'] == 1:
                #write_msgbase_subscription(current_mbase, 0)
                write_msgbase_subscription(user['mbase'], 0)
                items[selbar]['subbed'] = 0
                s = config.unsub_from_str.replace('|&1',items[selbar]['name'])
                msgdialog(' Unsubscribe ',s)
              elif items[selbar]['subbed'] == 0:
                #write_msgbase_subscription(current_mbase, 1)
                write_msgbase_subscription(user['mbase'], 1)
                items[selbar]['subbed'] = 1
                s = config.sub_to_str.replace('|&1',items[selbar]['name'])
                msgdialog(' Subscribe ',s)
              else:
                msgdialog(' Unsubscribe ',config.no_unsubscribe_str)


              # reload bases
              items = loadmainlist(True)

              # reposition selection bar
              #if 'ALL' not in actions or viewmode == "SUB":
              write('|RS')
              selbar, top = key_down(selbar, top)
              selbar, top = key_up(selbar, top)
              #selbar, top = set_area()              
              redraw = True
              


          elif key == KEY_ESCAPE or key == 'Q':
              done = True
 
          elif key == 'H' or key == KEY_CTRLZ:    
              write('|SS')
              write('|07|16|CL')

              showfile(rjamdir+'groups_help.ans',0,False,False,False)

              gotoxy(1,24)
              pause(True)
              write('|RS')
              #redraw = True
#------------------------------------------------------------------------------


################################################################################################################################
# Mail list
################################################################################################################################

def exist_at_index(obj, index):
    """Check if a value exists at a given index/key in a sequence or mapping."""
    try:
        return index in obj if hasattr(obj, '__contains__') else bool(obj[index] or True)
    except (IndexError, KeyError, TypeError):
        return False

#------------------------------------------------------------------------------
#get rid of mbaseid here totally unnecessary
#make sure to set_area() first when opening maillist, user['mbase'] is only read on initial run and updated during treelist
#but not when newmessage scan skips treelist if only one mailbase
def maillist(mbaseid, total_msgs=0, new_msgs=0):
  global last_msg_num
  global msgtext
  #global basename
  global msg_count
  global debug
  global msg_lastID
  global user
  global actions
  global msgbase #to close msgbase on leaving the mail list
  global mailbase
   
  global hdrlines 
  global current_msg

  #hdrlines = config2.getint('reader','max_header_lines')
  
  #msg_hdr_line_mod = 0
  current_msg = 1

  top_body  = 0
  top       = 0
  selbar    = -1
  done      = False
  start_y   = mci_extract_y(config2.get('reader','startpos'))
  msgtext   = None
  msglines  = 0
  echohdr   = False

  count = 0

  private_base = False
  #TODO move mailbase from here to within loop-- keep track of old/newmailbase and update header likewise
  mailbase = getmbaseid(mbaseid)
  #if mailbase['nettype'] == 0 or mailbase['nettype'] == 3:
  if bool(mailbase['flags'] & MB_Private):
    private_base = True

  menucmd('NA','rJAM - Reading Messages')
  sysoplog(1,'rJAM - Reading Messages - ' + mailbase['name'])

  #logerror('test')
  #logerror(str(msgbase))

  #if less messages then hdrlines possible
  if len(msgs) < hdrlines:
    top = 0
    while selbar == -1 and count < msg_count:
        if msgs[count]['msg_number'] > last_msg_num:
          selbar = count
          current_msg += 1

        count += 1

  else:
  # if more messages then hdrlines
    if last_msg_num > 0:
      while selbar == -1 and count < msg_count:  
        if msgs[count]['msg_number'] > last_msg_num:
          ## OLD! - if (user['mbase'] not in config.private_bases and 'YOU' not in actions) or ((user['mbase'] in config.private_bases or 'YOU' in actions) and (user["handle"].upper() == msgs[count]['msg_to'].upper() or user["name"].upper() == msgs[count]['msg_to'].upper())):
          
          #always jump to correct new message, also when only your mail is searched
          #if (not private_base and 'YOU' not in actions) or ((private_base or 'YOU' in actions) and (user["handle"].upper() == msgs[count]['msg_to'].upper() or user["name"].upper() == msgs[count]['msg_to'].upper())):
            selbar = count
            top = selbar

            # this works for public mail bases
            if new_msgs > hdrlines or private_base == False:
              current_msg = total_msgs - new_msgs + 1

            # this triggers is less new messages than msg header lines, or if private base
            else: 
              #this is a HEAVY approximation
              #current_msg = total_msgs - (msg_count - count) + 1
              
              #this works if there are less new msgs than the message lines in header
              current_msg = total_msgs - (len(msgs) - count) + 1
            break
      
        count += 1
    else:
      selbar = 0
      current_msg = 1

  #start at end if no lastread message found
  if selbar == -1:
    selbar = msg_count-1
    top = msg_count-hdrlines-1
    current_msg = total_msgs

  #make sure no gap at bottom
  elif selbar > hdrlines - 1:
    top = msg_count - hdrlines - 1

  #adjust top if necessary
  if top<0:
    top = 0

  drawbackground()

  prevmailhdr = None
  redraw_hdr = True

  # MAIN LOOP

  while done == False and start_y != -1 and not shutdown() and msg_count > 0:
    
    y = top  

    # draw message headers  
    if redraw_hdr == True:

      #draw header
      if prevmailhdr == None or (exist_at_index(msgs[selbar],'mbase') and msgs[selbar]['mbase'] <> prevmailhdr):
          prevmailhdr = mailbase['id']
          ypos = mci_extract_y(config2.get('body','msg_body_startpos'))+2
          write('|#X#2##4#'+str(ypos).zfill(2)+'#44#'+str(ypos+4).zfill(2)+'#')
          gotoxy(5,ypos+2)
          write(' |14>> |15'+mailbase['name'])

      #gotoxy(1,1)
      #write(str(current_msg)+' '+str(total_msgs)+' ')
      if total_msgs > 0 and config2.getboolean('reader','adjustable_size') == False:
        updatebar(config2.get('reader','barpos'), current_msg, total_msgs, config2.getint('reader','max_header_lines'), True, redraw_hdr)

      while y-top<=hdrlines: #+msg_hdr_line_mod: 

        pos = mci_adjust_y(config2.get('reader','startpos'),(y*config2.getint('reader','header_lines'))-(top*config2.getint('reader','header_lines')))      
        write(pos)

        if y<msg_count:                  
          msg = msgs[y]
        
          if selbar == y:    
            s = config2.get('reader','hdr_str_selected') #config.hdr_str_selected        
          else:
            s = config2.get('reader','hdr_str_new') #config.hdr_str      
          
          if selbar == y:
            setpinfo(8, '|08'+chr(250))
          else:  
            setpinfo(8, ' ')
          setpinfo(9, '')  #was used for readbit

          if last_msg_num < msgs[y]['msg_number']:
            #always show if message is new or not
            #if ('YOU' not in actions and user['mbase'] not in config.private_bases) or (user["handle"].upper() == msgs[y]['msg_to'].upper() or user["name"].upper() == msgs[y]['msg_to'].upper()):
            #if ('YOU' not in actions and not private_base) or (user["handle"].upper() == msgs[y]['msg_to'].upper() or user["name"].upper() == msgs[y]['msg_to'].upper()):
            if selbar != y:    
              s = config2.get('reader','hdr_str_new') #config.hdr_str_new
            setpinfo(8, '|14*')
            #else:
              #setpinfo(8, '|05>')
          else:
            setpinfo(8, ' ')
                  
          setpinfo(1, msg['msg_subject'])        
          setpinfo(2, msg['msg_from'][:17])
          setpinfo(3, msg['msg_to'][:17])
          setpinfo(4, msg['msg_date'])

          write(s)
        else:
          s = config2.get('reader','hdr_str_blank') #config.hdr_str      

          setpinfo(1, '')        
          setpinfo(2, '')
          setpinfo(3, '')
          setpinfo(4, '         ')
          setpinfo(8, '')
          setpinfo(9, '')
          write(s+' ')
          
        y += 1    

      if config2.getboolean('reader','adjustable_size'):
        write(mci_adjust_y(config2.get('body','msg_body_startpos'),-1))
        write(config.mid_first)
      #write(mci_adjust_y(config2.get('body','msg_body_startpos'),0))
      #write(config.mid_second)

      #write(mci_adjust_y(config.msg_body_startpos,-2))
      #write(mci_adjust_y(config2.get('reader','startpos'),config2.getint('reader','max_header_lines')+1))
      #write(config.mid_first)
      #write(mci_adjust_y(config.msg_body_startpos,-1))
      #write(mci_adjust_y(config2.get('reader','startpos'),config2.getint('reader','max_header_lines')+2))
      #write('|[K')
      #write(config.mid_second)

      top_body = 0    
      redraw_hdr = False  
      msgtext = None

      if config2.getboolean('body','show_details'):
        setpinfo(1, msgs[selbar]['msg_from'])
        setpinfo(2, msgs[selbar]['msg_to'])
        setpinfo(3, msgs[selbar]['msg_date'])
        setpinfo(4, msgs[selbar]['msg_subject'])
        write(config2.get('body','details_str'))
      
      # SAVE SCREEN
      write('|SS')

    top_body = draw_msg_body(msgs[selbar],selbar,top_body,False,echohdr)

    key, extended = getkey()
    key = key.upper()

    if extended:    

      if key == KEY_UP:
        redraw_hdr = True      
        selbar -= 1
        current_msg -= 1
        if current_msg < 1:
          current_msg = 1

        if selbar < 0:
            selbar = 0
            if not load_prevmsg(msgs[selbar]['msg_number']):
              redraw_hdr = False
            #else:
            #  current_msg -= 1

        if selbar < top:
            top = selbar    

        

      elif key == KEY_DOWN:
        redraw_hdr = True      
        selbar += 1
        current_msg += 1
        if current_msg > total_msgs:
          current_msg = total_msgs

        if selbar >= msg_count: 
            selbar = msg_count-1
            if load_nextmsg(msgs[selbar]['msg_number']):
              selbar = msg_count-1
              top += 1
              #current_msg += 1
            else:  
              redraw_hdr = False
            

        elif selbar > top+hdrlines: 
            top += 1

      elif key == KEY_LEFT:
          top_body -= 1

      elif key == KEY_RIGHT:
          top_body += 1

      elif key == KEY_PGUP:
        redraw_hdr = True
        selbar = selbar - hdrlines - 1
        if current_msg > 1:
          current_msg -= hdrlines + 1
          if current_msg < 1:
            current_msg = 1
        else:
          #this is the LAZY way to avoid redraw!
          #we should create a check based on prevmsg or something
          redraw_hdr = False

        if selbar < 0:
            for i in range(0, selbar, -1):
              #current_msg += 1
              selbar = 0
              load_prevmsg(msgs[selbar]['msg_number'])
              #current_msg -= 1

            selbar = 0
            top = 0
            #current_msg = 0
        else:
            #current_msg = 0
            top = top - hdrlines - 1
            #current_msg -= hdrlines - 1
            if top < 0:
                top = 0

      elif key == KEY_PGDN:
        redraw_hdr = True
        selbar = selbar+hdrlines + 1
        if current_msg < total_msgs:
          current_msg += hdrlines + 1
          if current_msg > total_msgs:
            current_msg = total_msgs
        else:
          #this is the LAZY way to avoid redraw!
          #we should create a check based on prevmsg or something
          redraw_hdr = False

        if selbar > msg_count - 1:
            for i in range(msg_count - 1, selbar, 1):
              #current_msg -= 1
              selbar = msg_count - 1
              
              if load_nextmsg(msgs[selbar]['msg_number']):
                  #current_msg += 1
                  selbar = msg_count-1
                  top += 1
                  #current_msg += 1
        
        top = top+(hdrlines) + 1
        
        if top > msg_count-1-hdrlines:
            top = msg_count-1-hdrlines
            if top < 0:
                top = 0

      elif key == KEY_END:
        
        get_msgs( msg_lastID )
        current_msg = total_msgs

        redraw_hdr = True
        selbar=msg_count-1
        if msg_count-hdrlines-1 > 0:
            top = msg_count-hdrlines-1
        else:
            top = 0

      elif key == KEY_HOME:
        current_msg = 1
        get_msgs(0)
        redraw_hdr = True
        selbar = 0
        top = 0
                
    else:

      if key == 'P':

        if debug == True:
          debug = False
        else:
          debug = True

      if key == KEY_ESCAPE or key == 'Q' or key == KEY_TAB:
        #clrscr()
        done = True

      if key == 'V':

        if echohdr == False:
          echohdr = True
        else:
          echohdr = False

        redraw_hdr = True
       
      if key == 'R':
        draw_msg_body(msgs[selbar],selbar,0,True) #dump message quote

        if last_msg_num < msgs[selbar]['msg_number']:
          last_msg_num = write_last_read_msg_num(msgs[selbar]['msg_number'],False)
          
        to = msgs[selbar]['msg_from']
        to = to.replace(' ','_')  #spaces bug the response..

        subject = msgs[selbar]['msg_subject']
        subject = subject.replace(' ','_')  #spaces bug the response..
        subject = subject.replace('/F','\F')  #/F is seen as /FORCED no matter what

        sysoplog(1,'rJAM - Replying to message - ' + msgs[selbar]['msg_from'] + ' - ' + msgs[selbar]['msg_subject'])

        #if basename == "EMAIL":
        #if issysop():
        #    writeln('  '+to+'|PN')
            #writeln('   '+str(mailbase['nettype']))
            #writeln('   '+bin(mailbase['flags'])[2:].zfill(8))
            #writeln('   PVT '+str(bool(mailbase['flags'] & MB_Private)))
            #writeln('   PVT '+str(bool(mailbase['flags'] & MB_Autosigs))+'|PN')
            
        #only use MW on local mail and private base
        if mailbase['nettype'] == 0 and bool(mailbase['flags'] & MB_Private):
        
        # SO WE CAN ONLY HAVE ONE LOCAL PRIVATE MSG BOX, ALL OTHER LOCAL MSG BASES NEED TO BE PUBLIC

        #if 2==1:
        #if mailbase['nettype'] == 0: # and mailbase['flags'] != 68:
          #if user['mbase'] in config.private_bases:                  
                    # NetType //0=Local 1=Echo 2=News 3=Net
                    # 1 =  0 
                    # 27 = 3
                    # 71 = 2
                    # 73 = 2
                    # 41 = 1
                    # FLAGS
                    # 1 =  01010000 localmsg          MW
                    # 27 = 01010100 netmail           
                    # 71 = 01010000 TEST2             
                    # 73 = 01000100 general public    MP
                    # 41 = 01000100 echo public       MP

          menucmd('MW','/to:'+to+' /subj:'+subject)
        #elif mailbase['nettype'] == 3 or mailbase['nettype'] == 1: # or mailbase['flags'] == 68:
        else:
          msgtext = get_msg_body(selbar, msgs[selbar],True)
          msgtext = multiple_replace(msgtext, config.rep)
          msgtext = utf_to_ascii( msgtext )
          start = msgtext.find("MSGID:")
        
          if start > -1:
            start += 8
            end = msgtext.find(" ",start)
            addr = msgtext[start:end]

            if len(addr) > 1:
              menucmd('MP','/to:'+to+' /subj:'+subject+' /addr:'+addr)

          else:
            menucmd('MP','/to:'+to+' /subj:'+subject)
          
        redraw_hdr = True
        #drawbackground()
        write('|RS')


      if key == 'F':

        draw_msg_body(msgs[selbar],selbar,0,True) #dump message quote

        if last_msg_num < msgs[selbar]['msg_number']:
          last_msg_num = write_last_read_msg_num(msgs[selbar]['msg_number'],False)
          
        #to = msgs[selbar]['msg_from']
        #to = to.replace(' ','_')  #spaces bug the response..
        
        write('|#X#2##20#6#60#10#')
        write('|[X22|[Y08|07Forward to |08[.......................]')
        write('|[X34|[Y08')
        to = getstr(11, 23, 23, "")

        if to != None and len(to) > 1:

          subject = msgs[selbar]['msg_subject']
          subject = subject.replace(' ','_')  #spaces bug the response..
          to = to.replace(' ','_')  #spaces bug the receiver..
          subject = subject.replace('/F','\F')  #/F is seen as /FORCED no matter what

          if subject.find('Re:_') == 0:
            subject = subject.replace('Re:_','')

          if subject.find('Fw:') == -1:
            subject = 'Fw:_'+subject

          #only use MW on local mail and private base
          if mailbase['nettype'] == 0 and bool(mailbase['flags'] & MB_Private):

            #if user['mbase'] in config.private_bases:                  
            menucmd('MW','/to:'+to+' /subj:'+subject)
          else:
          #elif mailbase['nettype'] == 3 or mailbase['nettype'] == 1:
            write('|CL')
            menucmd('MP','/to:'+to+' /subj:'+subject+' /addr: ')

        #drawbackground()
        write('|RS')
        redraw_hdr = True    
        #redraw = True 

      elif key == KEY_ENTER:

        if last_msg_num < msgs[selbar]['msg_number']:
          last_msg_num = write_last_read_msg_num(msgs[selbar]['msg_number'],False)          
        #else:
        #  last_msg_num = write_last_read_msg_num(msgs[selbar]['msg_number']-1, True)
        redraw_hdr = True   

      elif key == 'N':

        write('|#X#2##20#6#60#10#')
        write('|[X22|[Y08|07Send to    |08[.......................]')
        write('|[X34|[Y08')

        if mailbase['nettype'] == 1:
          to = getstr(11, 23, 23, "All")
        else:
          to = getstr(11, 23, 23, "")


        if to != None and len(to) > 1:

          to = to.replace(' ','_')  #spaces bug the receiver..

          write('|#X#2##10#6#70#10#')
          write('|[X12|[Y08|07Subject    |08[...........................................]')
          write('|[X24|[Y08')
          subject = getstr(11, 43, 43, "")

          if subject != None and len(subject) > 1:

            subject = subject.replace(' ','_')  #spaces bug the receiver..
            subject = subject.replace('/F','\F')  #/F is seen as /FORCED no matter what

            sysoplog(1,'rJAM - Writing new message - ' + to + ' - ' + subject)

            #only use MW on local mail and private base
            if mailbase['nettype'] == 0 and bool(mailbase['flags'] & MB_Private):

              #if mbaseid == config.private_bases[0]:
              menucmd('MW','/to:'+to+' /subj:'+subject)
            else:
            #elif mailbase['nettype'] == 3 or mailbase['nettype'] == 1:
              write('|CL')
              write('|IF')
              menucmd('MP','/to:'+to+' /subj:'+subject)

            #load new message at end of 
            if load_nextmsg(msgs[len(msgs)-1]['msg_number']):
              total_msgs += 1
            
        #drawbackground()
        write('|RS')
        redraw_hdr = True    
        #redraw = True 

      elif key == '[' and config2.getboolean('reader','adjustable_size'):
          if hdrlines > 1:
            #config2.set('reader','max_header_lines', config2.getint('reader','max_header_lines')-1 )
            hdrlines -= 1
            config2.set('body','max_body_lines', config2.getint('body','max_body_lines')+1 )
            #config2.getint('reader','max_header_lines') -= 1
            #config.msg_body_startpos = mci_adjust_y(config.msg_body_startpos,-1)
            config2.set('body','msg_body_startpos', mci_adjust_y(config2.get('body','msg_body_startpos'),-1))
            #config.max_body_lines += 1

            if selbar > top + hdrlines:
              top += 1

            if selbar < 0:
              top += 1
      
            redraw_hdr = True

            #write(mci_adjust_y(config.msg_body_startpos,-2))
            #write(config.mid_first)
            #write(mci_adjust_y(config.msg_body_startpos,-1))
            #write(config.mid_second)
      
      elif key == ']' and config2.getboolean('reader','adjustable_size'):
          if hdrlines < config2.getint('reader','max_header_lines'):
            #config2.set('reader','max_header_lines', config2.getint('reader','max_header_lines')+1 )
            hdrlines += 1
            config2.set('body','max_body_lines', config2.getint('body','max_body_lines')-1 )
            #config2.getint('reader','max_header_lines') += 1
            #config.msg_body_startpos = mci_adjust_y(config.msg_body_startpos, 1)
            config2.set('body','msg_body_startpos', mci_adjust_y(config2.get('body','msg_body_startpos'),1))

            #config.max_body_lines += -1
          

            #increase messages when on start of messagebase
            if selbar<hdrlines:
              #gotoxy(1,1)
              #write(str(len(msgs)))
              load_nextmsg(msgs[len(msgs)-1]['msg_number'])
                #selbar += 1
            
            #load prev message when in end of messagebase
            if y-top<=hdrlines:
              if load_prevmsg(msgs[0]['msg_number']):
                selbar += 1
                top += 1
                #top -= 1
                #if selbar < len(msgs) - 1:
                #  selbar += 1


            if top > 0 and top < hdrlines:
              top -= 1
            elif top > msg_count - hdrlines - 1 and msg_count > hdrlines:
              top -= 1

            redraw_hdr = True

            #write(mci_adjust_y(config.msg_body_startpos,-2))
            #write(config.mid_first)
            #write(mci_adjust_y(config.msg_body_startpos,-1))
            #write(config.mid_second)


      elif key == 'S':

          last_msg_num = write_last_read_msg_num(msgs[selbar]['msg_number']-1, True)
          redraw_hdr = True
          
      elif key == 'D':
          
          #only allow delete of send and received messages
          private_base = False
          #if mailbase['nettype'] == 0 or mailbase['nettype'] == 3:
          if bool(mailbase['flags'] & MB_Private):
            private_base = True

          #if issysop() or (user['mbase'] in config.private_bases and msgs[selbar]['msg_to'].upper() == user['handle'].upper() or msgs[selbar]['msg_from'].upper() == user['handle'].upper() or msgs[selbar]['msg_to'].upper() == user['name'].upper() or msgs[selbar]['msg_from'].upper() == user['name'].upper()):
          if issysop() or (private_base and msgs[selbar]['msg_to'].upper() == user['handle'].upper() or msgs[selbar]['msg_from'].upper() == user['handle'].upper() or msgs[selbar]['msg_to'].upper() == user['name'].upper() or msgs[selbar]['msg_from'].upper() == user['name'].upper()):

            delete_msg_num(selbar, msgs[selbar])
            total_msgs -= 1

            s = config.delete_msg
            msgdialog(' Delete ',s)

            del(msgs[selbar])
            msg_count = len(msgs)

            #make sure we dont go out of bounds
            if selbar > msg_count - 1:
              selbar = msg_count - 1
              top -= 1
            if top < 0:
              top = 0

            redraw_hdr = True
            write('|RS')

  msg_close(msgbase)

#------------------------------------------------------------------------------


#------------------------------------------------------------------------------------------------------
# replace prompts
#------------------------------------------------------------------------------------------------------

def replace_prompts():
  
  global prompt_108
  global prompt_109
  global prompt_119

  #108 Sent private message to
  prompt_108 = getprompt(108)
  setprompt(108, '|IF|00')

  #109 message aborted, press enter
  prompt_109 = getprompt(109)
  setprompt(109, '|IF|00')

  #119 Post message to
  prompt_119 = getprompt(119)
  setprompt(119, '|IF|00')


#------------------------------------------------------------------------------
# restore prompts
#------------------------------------------------------------------------------
def restore_prompts():

  global prompt_108
  global prompt_109
  global prompt_119

  #108 Sent private message to
  setprompt(108, prompt_108)

  #109 message aborted, press enter
  setprompt(109, prompt_109)

  #119 Post message to
  setprompt(119, prompt_119)

  

######################################################################################################################
# MAIN
######################################################################################################################

def main():

  #global config2

  global actions
  global cfg
  global user
  global viewmode
  global items
  #global current_mbase
  global sysop_level
   
  #------------------------------------------------------------------------------
  cfg           = getcfg()   
  user          = getuser(0) 
  #gotoxy(1,1)
  #writeln(str(user['mbase'])+"    ")
  #sleep(1)

  #TODO: could be removed if we use user['mbase'] instead everywhere
  #current_mbase = user['mbase']
  file          = ""
  msg_count     = 0
  sysop_level   = int(re.findall(r'\d+', cfg['sysopacs'])[0])
  viewmode      = "SUB"
  mailbase      = False

  actions = []

  load_config()

  global hdrlines
  hdrlines = config2.getint('reader','start_header_lines')

  #temporaly only show mail addressed to you in netmail/email/private
  #actions.append('NOFROM')
  replace_prompts()

  i = 1
  while i <= param_count():
    arg = param_str(i).upper()  
    
    if arg == "/YOU":
      actions.append('YOU')

    #could be done with menu command and then list
    elif arg == "/EMAIL":
      actions.append('EMAIL')

    elif arg == "/EMAILNETMAIL":
      actions.append('EMAILNETMAIL')

    elif arg == "/NOFROM":
      actions.append('NOFROM')

    elif arg == "/MAILLIST":
      actions.append('MAILLIST')

    elif arg == "/AREASELECT":
      actions.append('AREASELECT')

    elif arg == "/NEW":
      actions.append('NEW')

    elif arg == "/ALL":
      actions.append('ALL')
      viewmode = "ALL"

    #not implemented yet - split or full message reader  
    #elif arg == "/SPLIT":
    #  actions.append('SPLIT')

    elif arg == "/CHANGEAREA":
      actions.append('CHANGEAREA')
      arg = param_str(i+1)
      if arg == "-":
        actions.append('BACKWARD')
      elif arg == "+":
        actions.append('FORWARD')
      i += 1

    i += 1

  #moved from if block
  get_mailbases()

  if 'CHANGEAREA' in actions:
    #moved up to make sure that the following else block can read through mailbases
    #get_mailbases()
    get_subscriptions()

    res = []
    for i in range(len(mailbases)):
      if mailbases[i]['subbed'] > 0:
        res.append(mailbases[i])
    
    for i in range(len(res)):
        #TODO: could be user['mbase'], CHANGED GET_SUBSCRIPTIONS TO AVOID CHANGING USER['mbase']!!
        #if res[i]['id'] == current_mbase:
        if res[i]['id'] == user['mbase']:

          next = i
          if "BACKWARD" in actions:
            next -= 1
          elif "FORWARD" in actions:
            next += 1     

          if next < 0:
            next = len(res)-1
          elif next > len(res)-1:
            next = 0

          if res[next]['groupid'] != -1:
            menucmd('MG',str(res[next]['groupid']))
          menucmd('MA',str(res[next]['id'])) 

          #gotoxy(1,2)
          #writeln(str(user['mbase'])+"    ")
          #writeln(str(res[next]['id'])+"   ")          
          break

    #if tmpid != None:
    #  user['mbase'] = tmpid

          #user['mbase'] = res[next]['id']

  else:

    if "MAILLIST" in actions or "EMAIL" in actions:  
      
      #private localmail
      if "EMAIL" in actions: 

        #try to find email base (localmail)
        for i in range(len(mailbases)):
          #if mailbases[i]['nettype'] == 0: 
          #only use MW on local mail and private base
          if mailbase[i]['nettype'] == 0 and bool(mailbase[i]['flags'] & MB_Private):
            mailbase = getmbaseid(mailbases[i]['id'])        
            index_msgs(mailbases[i]['id'])
            last_msg_num = get_last_read_msg_num()
            maillist(mailbases[i]['id'])
            break



        #index_msgs(config.private_bases[0])
        #last_msg_num = get_last_read_msg_num()
        #maillist(config.private_bases[0])

      #current mailarea
      else:      
        mailbase = getmbaseid(user['mbase'])
        index_msgs(user['mbase'])
        last_msg_num = get_last_read_msg_num()
        
        if msg_count == 0:    
          s = config.msg_no_messages.replace('|&1',mailbase['filename'].upper())
          msgdialog(' Mail ',s)          #show dialog and exit

        else:
          maillist(user['mbase'])
        
    else:
      # group/area choice
      items = loadmainlist()
      if len(items) > 0:
        treelist()

  restore_prompts()

#------------------------------------------------------------------------------


if __name__ == '__main__':
    main()

######################################################################################################################
